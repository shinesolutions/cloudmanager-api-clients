/**
 * Cloud Manager API
 * This API allows access to Cloud Manager programs, pipelines, and environments by an authorized technical account created through the Adobe I/O Console. The base url for this API is https://cloudmanager.adobe.io, e.g. to get the list of programs for an organization, you would make a GET request to https://cloudmanager.adobe.io/api/programs (with the correct set of headers as described below). This swagger file can be downloaded from https://raw.githubusercontent.com/AdobeDocs/cloudmanager-api-docs/master/swagger-specs/api.yaml.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: opensource@shinesolutions.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 4.3.1-SNAPSHOT.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "Metric.h"

#include <string>
#include <sstream>
#include <algorithm>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>

using boost::property_tree::ptree;
using boost::property_tree::read_json;
using boost::property_tree::write_json;

namespace org {
namespace openapitools {
namespace server {
namespace model {

Metric::Metric()
{
	m_Id = "";
	m_Severity = "";
	m_SeverityEnum = { "critical", "important", "informational" };
	m_Passed = false;
	m_Override = false;
	m_ActualValue = "";
	m_ExpectedValue = "";
	m_Comparator = "";
	m_ComparatorEnum = { "GT", "GTE", "LT", "LTE", "EQ", "NEQ" };
	m_Kpi = "";
}

Metric::~Metric()
{
}

std::string Metric::toJsonString(bool prettyJson)
{
	std::stringstream ss;
	write_json(ss, this->toPropertyTree(), prettyJson);
	return ss.str();
}

void Metric::fromJsonString(std::string const& jsonString)
{
	std::stringstream ss(jsonString);
	ptree pt;
	read_json(ss,pt);
	this->fromPropertyTree(pt);
}

ptree Metric::toPropertyTree()
{
	ptree pt;
	ptree tmp_node;
	pt.put("id", m_Id);
	pt.put("severity", m_Severity);
	pt.put("passed", m_Passed);
	pt.put("override", m_Override);
	pt.put("actualValue", m_ActualValue);
	pt.put("expectedValue", m_ExpectedValue);
	pt.put("comparator", m_Comparator);
	pt.put("kpi", m_Kpi);
	return pt;
}

void Metric::fromPropertyTree(ptree const &pt)
{
	ptree tmp_node;
	m_Id = pt.get("id", "");
	setSeverity(pt.get("severity", ""));
	m_Passed = pt.get("passed", false);
	m_Override = pt.get("override", false);
	m_ActualValue = pt.get("actualValue", "");
	m_ExpectedValue = pt.get("expectedValue", "");
	setComparator(pt.get("comparator", ""));
	m_Kpi = pt.get("kpi", "");
}

std::string Metric::getId() const
{
    return m_Id;
}
void Metric::setId(std::string value)
{
	m_Id = value;
}
std::string Metric::getSeverity() const
{
    return m_Severity;
}
void Metric::setSeverity(std::string value)
{
	if (std::find(m_SeverityEnum.begin(), m_SeverityEnum.end(), value) != m_SeverityEnum.end()) {
		m_Severity = value;
	}
}
bool Metric::isPassed() const
{
    return m_Passed;
}
void Metric::setPassed(bool value)
{
	m_Passed = value;
}
bool Metric::isOverride() const
{
    return m_Override;
}
void Metric::setOverride(bool value)
{
	m_Override = value;
}
std::string Metric::getActualValue() const
{
    return m_ActualValue;
}
void Metric::setActualValue(std::string value)
{
	m_ActualValue = value;
}
std::string Metric::getExpectedValue() const
{
    return m_ExpectedValue;
}
void Metric::setExpectedValue(std::string value)
{
	m_ExpectedValue = value;
}
std::string Metric::getComparator() const
{
    return m_Comparator;
}
void Metric::setComparator(std::string value)
{
	if (std::find(m_ComparatorEnum.begin(), m_ComparatorEnum.end(), value) != m_ComparatorEnum.end()) {
		m_Comparator = value;
	}
}
std::string Metric::getKpi() const
{
    return m_Kpi;
}
void Metric::setKpi(std::string value)
{
	m_Kpi = value;
}

}
}
}
}

