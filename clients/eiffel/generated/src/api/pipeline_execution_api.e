note
 description:"[
		Cloud Manager API
 		This API allows access to Cloud Manager programs, pipelines, and environments by an authorized technical account created through the Adobe I/O Console. The base url for this API is https://cloudmanager.adobe.io, e.g. to get the list of programs for an organization, you would make a GET request to https://cloudmanager.adobe.io/api/programs (with the correct set of headers as described below). This swagger file can be downloaded from https://raw.githubusercontent.com/AdobeDocs/cloudmanager-api-docs/master/swagger-specs/api.yaml.
  		The version of the OpenAPI document: 1.0.0
 	    Contact: opensource@shinesolutions.com

  	NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

 		 Do not edit the class manually.
 	]"
	date: "$Date$"
	revision: "$Revision$"
	EIS:"Eiffel openapi generator", "src=https://openapi-generator.tech", "protocol=uri"

class
	PIPELINEEXECUTION_API

inherit

    API_I


feature -- API Access


	advance_pipeline_execution (program_id: STRING_32; pipeline_id: STRING_32; execution_id: STRING_32; phase_id: STRING_32; step_id: STRING_32; x_gw_ims_org_id: STRING_32; authorization: STRING_32; x_api_key: STRING_32; content__type: STRING_32; body: ANY)
			-- Advance
			-- Post to this url in order to advance the current pipeline execution, if paused and waiting for user interaction. Link is present in output only in that case. The input depends on the actual reason for which the pipeline execution stopped.
			-- 
			-- argument: program_id Identifier of the program. (required)
			-- 
			-- argument: pipeline_id Identifier of the pipeline (required)
			-- 
			-- argument: execution_id Identifier of the execution (required)
			-- 
			-- argument: phase_id Identifier of the phase (required)
			-- 
			-- argument: step_id Identifier of the step (required)
			-- 
			-- argument: x_gw_ims_org_id IMS organization ID that the request is being made under. (required)
			-- 
			-- argument: authorization Bearer [token] - An access token for the technical account created through integration with Adobe IO (required)
			-- 
			-- argument: x_api_key IMS Client ID (API Key) which is subscribed to consume services on console.adobe.io (required)
			-- 
			-- argument: content__type Must always be application/json (required)
			-- 
			-- argument: body Input for advance. See documentation for details. (required)
			-- 
			-- 
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			l_request.set_body(body)
			l_path := "/api/program/{programId}/pipeline/{pipelineId}/execution/{executionId}/phase/{phaseId}/step/{stepId}/advance"
			l_path.replace_substring_all ("{"+"programId"+"}", api_client.url_encode (program_id.out))
			l_path.replace_substring_all ("{"+"pipelineId"+"}", api_client.url_encode (pipeline_id.out))
			l_path.replace_substring_all ("{"+"executionId"+"}", api_client.url_encode (execution_id.out))
			l_path.replace_substring_all ("{"+"phaseId"+"}", api_client.url_encode (phase_id.out))
			l_path.replace_substring_all ("{"+"stepId"+"}", api_client.url_encode (step_id.out))

			if attached x_gw_ims_org_id as l_x_gw_ims_org_id then
				l_request.add_header(l_x_gw_ims_org_id.out,"x-gw-ims-org-id");
			end
			if attached authorization as l_authorization then
				l_request.add_header(l_authorization.out,"Authorization");
			end
			if attached x_api_key as l_x_api_key then
				l_request.add_header(l_x_api_key.out,"x-api-key");
			end
			if attached content__type as l_content__type then
				l_request.add_header(l_content__type.out,"Content-Type");
			end

			if attached {STRING} api_client.select_header_accept (<<>>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<"application/json">>),"Content-Type")
			l_request.set_auth_names (<<>>)
			l_response := api_client.call_api (l_path, "Put", l_request, agent serializer, Void)
			if l_response.has_error then
				last_error := l_response.error
			end
		end	

	cancel_pipeline_execution_step (program_id: STRING_32; pipeline_id: STRING_32; execution_id: STRING_32; phase_id: STRING_32; step_id: STRING_32; x_gw_ims_org_id: STRING_32; authorization: STRING_32; x_api_key: STRING_32; content__type: STRING_32; body: ANY)
			-- Cancel
			-- Post to this url in order to cancel the current pipeline execution. Link is present in output only in that case.
			-- 
			-- argument: program_id Identifier of the program. (required)
			-- 
			-- argument: pipeline_id Identifier of the pipeline (required)
			-- 
			-- argument: execution_id Identifier of the execution (required)
			-- 
			-- argument: phase_id Identifier of the phase (required)
			-- 
			-- argument: step_id Identifier of the step (required)
			-- 
			-- argument: x_gw_ims_org_id IMS organization ID that the request is being made under. (required)
			-- 
			-- argument: authorization Bearer [token] - An access token for the technical account created through integration with Adobe IO (required)
			-- 
			-- argument: x_api_key IMS Client ID (API Key) which is subscribed to consume services on console.adobe.io (required)
			-- 
			-- argument: content__type Must always be application/json (required)
			-- 
			-- argument: body Input for advance. See documentation for details. (required)
			-- 
			-- 
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			l_request.set_body(body)
			l_path := "/api/program/{programId}/pipeline/{pipelineId}/execution/{executionId}/phase/{phaseId}/step/{stepId}/cancel"
			l_path.replace_substring_all ("{"+"programId"+"}", api_client.url_encode (program_id.out))
			l_path.replace_substring_all ("{"+"pipelineId"+"}", api_client.url_encode (pipeline_id.out))
			l_path.replace_substring_all ("{"+"executionId"+"}", api_client.url_encode (execution_id.out))
			l_path.replace_substring_all ("{"+"phaseId"+"}", api_client.url_encode (phase_id.out))
			l_path.replace_substring_all ("{"+"stepId"+"}", api_client.url_encode (step_id.out))

			if attached x_gw_ims_org_id as l_x_gw_ims_org_id then
				l_request.add_header(l_x_gw_ims_org_id.out,"x-gw-ims-org-id");
			end
			if attached authorization as l_authorization then
				l_request.add_header(l_authorization.out,"Authorization");
			end
			if attached x_api_key as l_x_api_key then
				l_request.add_header(l_x_api_key.out,"x-api-key");
			end
			if attached content__type as l_content__type then
				l_request.add_header(l_content__type.out,"Content-Type");
			end

			if attached {STRING} api_client.select_header_accept (<<>>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<"application/json">>),"Content-Type")
			l_request.set_auth_names (<<>>)
			l_response := api_client.call_api (l_path, "Put", l_request, agent serializer, Void)
			if l_response.has_error then
				last_error := l_response.error
			end
		end	

	current_execution (program_id: STRING_32; pipeline_id: STRING_32; x_gw_ims_org_id: STRING_32; authorization: STRING_32; x_api_key: STRING_32): detachable PIPELINE_EXECUTION
			-- Get current pipeline execution
			-- Returns current pipeline execution if any.
			-- 
			-- argument: program_id Identifier of the program. (required)
			-- 
			-- argument: pipeline_id Identifier of the pipeline (required)
			-- 
			-- argument: x_gw_ims_org_id IMS organization ID that the request is being made under. (required)
			-- 
			-- argument: authorization Bearer [token] - An access token for the technical account created through integration with Adobe IO (required)
			-- 
			-- argument: x_api_key IMS Client ID (API Key) which is subscribed to consume services on console.adobe.io (required)
			-- 
			-- 
			-- Result PIPELINE_EXECUTION
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/api/program/{programId}/pipeline/{pipelineId}/execution"
			l_path.replace_substring_all ("{"+"programId"+"}", api_client.url_encode (program_id.out))
			l_path.replace_substring_all ("{"+"pipelineId"+"}", api_client.url_encode (pipeline_id.out))

			if attached x_gw_ims_org_id as l_x_gw_ims_org_id then
				l_request.add_header(l_x_gw_ims_org_id.out,"x-gw-ims-org-id");
			end
			if attached authorization as l_authorization then
				l_request.add_header(l_authorization.out,"Authorization");
			end
			if attached x_api_key as l_x_api_key then
				l_request.add_header(l_x_api_key.out,"x-api-key");
			end

			if attached {STRING} api_client.select_header_accept (<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { PIPELINE_EXECUTION } l_response.data ({ PIPELINE_EXECUTION }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	execution (program_id: STRING_32; pipeline_id: STRING_32; execution_id: STRING_32; x_gw_ims_org_id: STRING_32; authorization: STRING_32; x_api_key: STRING_32): detachable PIPELINE_EXECUTION
			-- Get pipeline execution
			-- Returns a pipeline execution by id
			-- 
			-- argument: program_id Identifier of the program. (required)
			-- 
			-- argument: pipeline_id Identifier of the pipeline (required)
			-- 
			-- argument: execution_id Identifier of the execution (required)
			-- 
			-- argument: x_gw_ims_org_id IMS organization ID that the request is being made under. (required)
			-- 
			-- argument: authorization Bearer [token] - An access token for the technical account created through integration with Adobe IO (required)
			-- 
			-- argument: x_api_key IMS Client ID (API Key) which is subscribed to consume services on console.adobe.io (required)
			-- 
			-- 
			-- Result PIPELINE_EXECUTION
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/api/program/{programId}/pipeline/{pipelineId}/execution/{executionId}"
			l_path.replace_substring_all ("{"+"programId"+"}", api_client.url_encode (program_id.out))
			l_path.replace_substring_all ("{"+"pipelineId"+"}", api_client.url_encode (pipeline_id.out))
			l_path.replace_substring_all ("{"+"executionId"+"}", api_client.url_encode (execution_id.out))

			if attached x_gw_ims_org_id as l_x_gw_ims_org_id then
				l_request.add_header(l_x_gw_ims_org_id.out,"x-gw-ims-org-id");
			end
			if attached authorization as l_authorization then
				l_request.add_header(l_authorization.out,"Authorization");
			end
			if attached x_api_key as l_x_api_key then
				l_request.add_header(l_x_api_key.out,"x-api-key");
			end

			if attached {STRING} api_client.select_header_accept (<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { PIPELINE_EXECUTION } l_response.data ({ PIPELINE_EXECUTION }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	executions (program_id: STRING_32; pipeline_id: STRING_32; x_gw_ims_org_id: STRING_32; authorization: STRING_32; x_api_key: STRING_32; start: STRING_32; limit: INTEGER_32): detachable PIPELINE_EXECUTION_LIST_REPRESENTATION
			-- List Executions
			-- Returns the history of pipeline executions in a newest to oldest order
			-- 
			-- argument: program_id Identifier of the program. (required)
			-- 
			-- argument: pipeline_id Identifier of the pipeline (required)
			-- 
			-- argument: x_gw_ims_org_id IMS organization ID that the request is being made under. (required)
			-- 
			-- argument: authorization Bearer [token] - An access token for the technical account created through integration with Adobe IO (required)
			-- 
			-- argument: x_api_key IMS Client ID (API Key) which is subscribed to consume services on console.adobe.io (required)
			-- 
			-- argument: start Pagination start parameter (optional, default to null)
			-- 
			-- argument: limit Pagination limit parameter (optional, default to null)
			-- 
			-- 
			-- Result PIPELINE_EXECUTION_LIST_REPRESENTATION
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/api/program/{programId}/pipeline/{pipelineId}/executions"
			l_path.replace_substring_all ("{"+"programId"+"}", api_client.url_encode (program_id.out))
			l_path.replace_substring_all ("{"+"pipelineId"+"}", api_client.url_encode (pipeline_id.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", "start", start));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "limit", limit));

			if attached x_gw_ims_org_id as l_x_gw_ims_org_id then
				l_request.add_header(l_x_gw_ims_org_id.out,"x-gw-ims-org-id");
			end
			if attached authorization as l_authorization then
				l_request.add_header(l_authorization.out,"Authorization");
			end
			if attached x_api_key as l_x_api_key then
				l_request.add_header(l_x_api_key.out,"x-api-key");
			end

			if attached {STRING} api_client.select_header_accept (<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { PIPELINE_EXECUTION_LIST_REPRESENTATION } l_response.data ({ PIPELINE_EXECUTION_LIST_REPRESENTATION }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	start_pipeline (program_id: STRING_32; pipeline_id: STRING_32; x_gw_ims_org_id: STRING_32; authorization: STRING_32; x_api_key: STRING_32; content__type: STRING_32)
			-- Start the pipeline
			-- Starts the Pipeline. This works only if the pipeline is not already started.
			-- 
			-- argument: program_id Identifier of the program. (required)
			-- 
			-- argument: pipeline_id Identifier of the pipeline (required)
			-- 
			-- argument: x_gw_ims_org_id IMS organization ID that the request is being made under. (required)
			-- 
			-- argument: authorization Bearer [token] - An access token for the technical account created through integration with Adobe IO (required)
			-- 
			-- argument: x_api_key IMS Client ID (API Key) which is subscribed to consume services on console.adobe.io (required)
			-- 
			-- argument: content__type Must always be application/json (required)
			-- 
			-- 
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/api/program/{programId}/pipeline/{pipelineId}/execution"
			l_path.replace_substring_all ("{"+"programId"+"}", api_client.url_encode (program_id.out))
			l_path.replace_substring_all ("{"+"pipelineId"+"}", api_client.url_encode (pipeline_id.out))

			if attached x_gw_ims_org_id as l_x_gw_ims_org_id then
				l_request.add_header(l_x_gw_ims_org_id.out,"x-gw-ims-org-id");
			end
			if attached authorization as l_authorization then
				l_request.add_header(l_authorization.out,"Authorization");
			end
			if attached x_api_key as l_x_api_key then
				l_request.add_header(l_x_api_key.out,"x-api-key");
			end
			if attached content__type as l_content__type then
				l_request.add_header(l_content__type.out,"Content-Type");
			end

			if attached {STRING} api_client.select_header_accept (<<>>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<>>)
			l_response := api_client.call_api (l_path, "Put", l_request, agent serializer, Void)
			if l_response.has_error then
				last_error := l_response.error
			end
		end	

	step_logs (program_id: STRING_32; pipeline_id: STRING_32; execution_id: STRING_32; phase_id: STRING_32; step_id: STRING_32; x_gw_ims_org_id: STRING_32; authorization: STRING_32; x_api_key: STRING_32; file: STRING_32; accept: STRING_32)
			-- Get logs
			-- Get the logs associated with a step.
			-- 
			-- argument: program_id Identifier of the program. (required)
			-- 
			-- argument: pipeline_id Identifier of the pipeline (required)
			-- 
			-- argument: execution_id Identifier of the execution (required)
			-- 
			-- argument: phase_id Identifier of the phase (required)
			-- 
			-- argument: step_id Identifier of the step (required)
			-- 
			-- argument: x_gw_ims_org_id IMS organization ID that the request is being made under. (required)
			-- 
			-- argument: authorization Bearer [token] - An access token for the technical account created through integration with Adobe IO (required)
			-- 
			-- argument: x_api_key IMS Client ID (API Key) which is subscribed to consume services on console.adobe.io (required)
			-- 
			-- argument: file Identifier of the log file (optional, default to null)
			-- 
			-- argument: accept Specify application/json in this header to receive a JSON response. Otherwise, a 307 response code will be returned with a Location header. (optional, default to null)
			-- 
			-- 
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/api/program/{programId}/pipeline/{pipelineId}/execution/{executionId}/phase/{phaseId}/step/{stepId}/logs"
			l_path.replace_substring_all ("{"+"programId"+"}", api_client.url_encode (program_id.out))
			l_path.replace_substring_all ("{"+"pipelineId"+"}", api_client.url_encode (pipeline_id.out))
			l_path.replace_substring_all ("{"+"executionId"+"}", api_client.url_encode (execution_id.out))
			l_path.replace_substring_all ("{"+"phaseId"+"}", api_client.url_encode (phase_id.out))
			l_path.replace_substring_all ("{"+"stepId"+"}", api_client.url_encode (step_id.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", "file", file));

			if attached accept as l_accept then
				l_request.add_header(l_accept.out,"Accept");
			end
			if attached x_gw_ims_org_id as l_x_gw_ims_org_id then
				l_request.add_header(l_x_gw_ims_org_id.out,"x-gw-ims-org-id");
			end
			if attached authorization as l_authorization then
				l_request.add_header(l_authorization.out,"Authorization");
			end
			if attached x_api_key as l_x_api_key then
				l_request.add_header(l_x_api_key.out,"x-api-key");
			end

			if attached {STRING} api_client.select_header_accept (<<>>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, agent serializer, Void)
			if l_response.has_error then
				last_error := l_response.error
			end
		end	

	step_metric (program_id: STRING_32; pipeline_id: STRING_32; execution_id: STRING_32; phase_id: STRING_32; step_id: STRING_32; x_gw_ims_org_id: STRING_32; authorization: STRING_32; x_api_key: STRING_32): detachable PIPELINE_STEP_METRICS
			-- Get step metrics
			-- 
			-- 
			-- argument: program_id Identifier of the program. (required)
			-- 
			-- argument: pipeline_id Identifier of the pipeline (required)
			-- 
			-- argument: execution_id Identifier of the execution (required)
			-- 
			-- argument: phase_id Identifier of the phase (required)
			-- 
			-- argument: step_id Identifier of the step (required)
			-- 
			-- argument: x_gw_ims_org_id IMS organization ID that the request is being made under. (required)
			-- 
			-- argument: authorization Bearer [token] - An access token for the technical account created through integration with Adobe IO (required)
			-- 
			-- argument: x_api_key IMS Client ID (API Key) which is subscribed to consume services on console.adobe.io (required)
			-- 
			-- 
			-- Result PIPELINE_STEP_METRICS
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/api/program/{programId}/pipeline/{pipelineId}/execution/{executionId}/phase/{phaseId}/step/{stepId}/metrics"
			l_path.replace_substring_all ("{"+"programId"+"}", api_client.url_encode (program_id.out))
			l_path.replace_substring_all ("{"+"pipelineId"+"}", api_client.url_encode (pipeline_id.out))
			l_path.replace_substring_all ("{"+"executionId"+"}", api_client.url_encode (execution_id.out))
			l_path.replace_substring_all ("{"+"phaseId"+"}", api_client.url_encode (phase_id.out))
			l_path.replace_substring_all ("{"+"stepId"+"}", api_client.url_encode (step_id.out))

			if attached x_gw_ims_org_id as l_x_gw_ims_org_id then
				l_request.add_header(l_x_gw_ims_org_id.out,"x-gw-ims-org-id");
			end
			if attached authorization as l_authorization then
				l_request.add_header(l_authorization.out,"Authorization");
			end
			if attached x_api_key as l_x_api_key then
				l_request.add_header(l_x_api_key.out,"x-api-key");
			end

			if attached {STRING} api_client.select_header_accept (<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { PIPELINE_STEP_METRICS } l_response.data ({ PIPELINE_STEP_METRICS }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	step_state (program_id: STRING_32; pipeline_id: STRING_32; execution_id: STRING_32; phase_id: STRING_32; step_id: STRING_32; x_gw_ims_org_id: STRING_32; authorization: STRING_32; x_api_key: STRING_32): detachable PIPELINE_EXECUTION_STEP_STATE
			-- Get step state
			-- 
			-- 
			-- argument: program_id Identifier of the program. (required)
			-- 
			-- argument: pipeline_id Identifier of the pipeline (required)
			-- 
			-- argument: execution_id Identifier of the execution (required)
			-- 
			-- argument: phase_id Identifier of the phase (required)
			-- 
			-- argument: step_id Identifier of the step (required)
			-- 
			-- argument: x_gw_ims_org_id IMS organization ID that the request is being made under. (required)
			-- 
			-- argument: authorization Bearer [token] - An access token for the technical account created through integration with Adobe IO (required)
			-- 
			-- argument: x_api_key IMS Client ID (API Key) which is subscribed to consume services on console.adobe.io (required)
			-- 
			-- 
			-- Result PIPELINE_EXECUTION_STEP_STATE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/api/program/{programId}/pipeline/{pipelineId}/execution/{executionId}/phase/{phaseId}/step/{stepId}"
			l_path.replace_substring_all ("{"+"programId"+"}", api_client.url_encode (program_id.out))
			l_path.replace_substring_all ("{"+"pipelineId"+"}", api_client.url_encode (pipeline_id.out))
			l_path.replace_substring_all ("{"+"executionId"+"}", api_client.url_encode (execution_id.out))
			l_path.replace_substring_all ("{"+"phaseId"+"}", api_client.url_encode (phase_id.out))
			l_path.replace_substring_all ("{"+"stepId"+"}", api_client.url_encode (step_id.out))

			if attached x_gw_ims_org_id as l_x_gw_ims_org_id then
				l_request.add_header(l_x_gw_ims_org_id.out,"x-gw-ims-org-id");
			end
			if attached authorization as l_authorization then
				l_request.add_header(l_authorization.out,"Authorization");
			end
			if attached x_api_key as l_x_api_key then
				l_request.add_header(l_x_api_key.out,"x-api-key");
			end

			if attached {STRING} api_client.select_header_accept (<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type (<<>>),"Content-Type")
			l_request.set_auth_names (<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { PIPELINE_EXECUTION_STEP_STATE } l_response.data ({ PIPELINE_EXECUTION_STEP_STATE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	


end
