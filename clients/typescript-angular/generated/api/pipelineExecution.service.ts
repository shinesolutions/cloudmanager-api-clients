/**
 * Cloud Manager API
 * This API allows access to Cloud Manager programs, pipelines, and environments by an authorized technical account created through the Adobe I/O Console. The base url for this API is https://cloudmanager.adobe.io, e.g. to get the list of programs for an organization, you would make a GET request to https://cloudmanager.adobe.io/api/programs (with the correct set of headers as described below). This swagger file can be downloaded from https://raw.githubusercontent.com/AdobeDocs/cloudmanager-api-docs/master/swagger-specs/api.yaml.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: opensource@shinesolutions.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

import { PipelineExecution } from '../model/models';
import { PipelineExecutionListRepresentation } from '../model/models';
import { PipelineExecutionStepState } from '../model/models';
import { PipelineStepMetrics } from '../model/models';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';



@Injectable({
  providedIn: 'root'
})
export class PipelineExecutionService {

    protected basePath = 'https://cloudmanager.adobe.io';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }



    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key,
                        (value as Date).toISOString().substr(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
     * Advance
     * Post to this url in order to advance the current pipeline execution, if paused and waiting for user interaction. Link is present in output only in that case. The input depends on the actual reason for which the pipeline execution stopped.
     * @param programId Identifier of the program.
     * @param pipelineId Identifier of the pipeline
     * @param executionId Identifier of the execution
     * @param phaseId Identifier of the phase
     * @param stepId Identifier of the step
     * @param xGwImsOrgId IMS organization ID that the request is being made under.
     * @param authorization Bearer [token] - An access token for the technical account created through integration with Adobe IO
     * @param xApiKey IMS Client ID (API Key) which is subscribed to consume services on console.adobe.io
     * @param contentType Must always be application/json
     * @param body Input for advance. See documentation for details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public advancePipelineExecution(programId: string, pipelineId: string, executionId: string, phaseId: string, stepId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, contentType: string, body: object, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public advancePipelineExecution(programId: string, pipelineId: string, executionId: string, phaseId: string, stepId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, contentType: string, body: object, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public advancePipelineExecution(programId: string, pipelineId: string, executionId: string, phaseId: string, stepId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, contentType: string, body: object, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public advancePipelineExecution(programId: string, pipelineId: string, executionId: string, phaseId: string, stepId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, contentType: string, body: object, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (programId === null || programId === undefined) {
            throw new Error('Required parameter programId was null or undefined when calling advancePipelineExecution.');
        }
        if (pipelineId === null || pipelineId === undefined) {
            throw new Error('Required parameter pipelineId was null or undefined when calling advancePipelineExecution.');
        }
        if (executionId === null || executionId === undefined) {
            throw new Error('Required parameter executionId was null or undefined when calling advancePipelineExecution.');
        }
        if (phaseId === null || phaseId === undefined) {
            throw new Error('Required parameter phaseId was null or undefined when calling advancePipelineExecution.');
        }
        if (stepId === null || stepId === undefined) {
            throw new Error('Required parameter stepId was null or undefined when calling advancePipelineExecution.');
        }
        if (xGwImsOrgId === null || xGwImsOrgId === undefined) {
            throw new Error('Required parameter xGwImsOrgId was null or undefined when calling advancePipelineExecution.');
        }
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling advancePipelineExecution.');
        }
        if (xApiKey === null || xApiKey === undefined) {
            throw new Error('Required parameter xApiKey was null or undefined when calling advancePipelineExecution.');
        }
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling advancePipelineExecution.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling advancePipelineExecution.');
        }

        let headers = this.defaultHeaders;
        if (xGwImsOrgId !== undefined && xGwImsOrgId !== null) {
            headers = headers.set('x-gw-ims-org-id', String(xGwImsOrgId));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        if (xApiKey !== undefined && xApiKey !== null) {
            headers = headers.set('x-api-key', String(xApiKey));
        }
        if (contentType !== undefined && contentType !== null) {
            headers = headers.set('Content-Type', String(contentType));
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.put<any>(`${this.configuration.basePath}/api/program/${encodeURIComponent(String(programId))}/pipeline/${encodeURIComponent(String(pipelineId))}/execution/${encodeURIComponent(String(executionId))}/phase/${encodeURIComponent(String(phaseId))}/step/${encodeURIComponent(String(stepId))}/advance`,
            body,
            {
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Cancel
     * Post to this url in order to cancel the current pipeline execution. Link is present in output only in that case.
     * @param programId Identifier of the program.
     * @param pipelineId Identifier of the pipeline
     * @param executionId Identifier of the execution
     * @param phaseId Identifier of the phase
     * @param stepId Identifier of the step
     * @param xGwImsOrgId IMS organization ID that the request is being made under.
     * @param authorization Bearer [token] - An access token for the technical account created through integration with Adobe IO
     * @param xApiKey IMS Client ID (API Key) which is subscribed to consume services on console.adobe.io
     * @param contentType Must always be application/json
     * @param body Input for advance. See documentation for details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public cancelPipelineExecutionStep(programId: string, pipelineId: string, executionId: string, phaseId: string, stepId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, contentType: string, body: object, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public cancelPipelineExecutionStep(programId: string, pipelineId: string, executionId: string, phaseId: string, stepId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, contentType: string, body: object, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public cancelPipelineExecutionStep(programId: string, pipelineId: string, executionId: string, phaseId: string, stepId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, contentType: string, body: object, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public cancelPipelineExecutionStep(programId: string, pipelineId: string, executionId: string, phaseId: string, stepId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, contentType: string, body: object, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (programId === null || programId === undefined) {
            throw new Error('Required parameter programId was null or undefined when calling cancelPipelineExecutionStep.');
        }
        if (pipelineId === null || pipelineId === undefined) {
            throw new Error('Required parameter pipelineId was null or undefined when calling cancelPipelineExecutionStep.');
        }
        if (executionId === null || executionId === undefined) {
            throw new Error('Required parameter executionId was null or undefined when calling cancelPipelineExecutionStep.');
        }
        if (phaseId === null || phaseId === undefined) {
            throw new Error('Required parameter phaseId was null or undefined when calling cancelPipelineExecutionStep.');
        }
        if (stepId === null || stepId === undefined) {
            throw new Error('Required parameter stepId was null or undefined when calling cancelPipelineExecutionStep.');
        }
        if (xGwImsOrgId === null || xGwImsOrgId === undefined) {
            throw new Error('Required parameter xGwImsOrgId was null or undefined when calling cancelPipelineExecutionStep.');
        }
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling cancelPipelineExecutionStep.');
        }
        if (xApiKey === null || xApiKey === undefined) {
            throw new Error('Required parameter xApiKey was null or undefined when calling cancelPipelineExecutionStep.');
        }
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling cancelPipelineExecutionStep.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling cancelPipelineExecutionStep.');
        }

        let headers = this.defaultHeaders;
        if (xGwImsOrgId !== undefined && xGwImsOrgId !== null) {
            headers = headers.set('x-gw-ims-org-id', String(xGwImsOrgId));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        if (xApiKey !== undefined && xApiKey !== null) {
            headers = headers.set('x-api-key', String(xApiKey));
        }
        if (contentType !== undefined && contentType !== null) {
            headers = headers.set('Content-Type', String(contentType));
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.put<any>(`${this.configuration.basePath}/api/program/${encodeURIComponent(String(programId))}/pipeline/${encodeURIComponent(String(pipelineId))}/execution/${encodeURIComponent(String(executionId))}/phase/${encodeURIComponent(String(phaseId))}/step/${encodeURIComponent(String(stepId))}/cancel`,
            body,
            {
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get current pipeline execution
     * Returns current pipeline execution if any.
     * @param programId Identifier of the program.
     * @param pipelineId Identifier of the pipeline
     * @param xGwImsOrgId IMS organization ID that the request is being made under.
     * @param authorization Bearer [token] - An access token for the technical account created through integration with Adobe IO
     * @param xApiKey IMS Client ID (API Key) which is subscribed to consume services on console.adobe.io
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCurrentExecution(programId: string, pipelineId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<PipelineExecution>;
    public getCurrentExecution(programId: string, pipelineId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<PipelineExecution>>;
    public getCurrentExecution(programId: string, pipelineId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<PipelineExecution>>;
    public getCurrentExecution(programId: string, pipelineId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {
        if (programId === null || programId === undefined) {
            throw new Error('Required parameter programId was null or undefined when calling getCurrentExecution.');
        }
        if (pipelineId === null || pipelineId === undefined) {
            throw new Error('Required parameter pipelineId was null or undefined when calling getCurrentExecution.');
        }
        if (xGwImsOrgId === null || xGwImsOrgId === undefined) {
            throw new Error('Required parameter xGwImsOrgId was null or undefined when calling getCurrentExecution.');
        }
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getCurrentExecution.');
        }
        if (xApiKey === null || xApiKey === undefined) {
            throw new Error('Required parameter xApiKey was null or undefined when calling getCurrentExecution.');
        }

        let headers = this.defaultHeaders;
        if (xGwImsOrgId !== undefined && xGwImsOrgId !== null) {
            headers = headers.set('x-gw-ims-org-id', String(xGwImsOrgId));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        if (xApiKey !== undefined && xApiKey !== null) {
            headers = headers.set('x-api-key', String(xApiKey));
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<PipelineExecution>(`${this.configuration.basePath}/api/program/${encodeURIComponent(String(programId))}/pipeline/${encodeURIComponent(String(pipelineId))}/execution`,
            {
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get pipeline execution
     * Returns a pipeline execution by id
     * @param programId Identifier of the program.
     * @param pipelineId Identifier of the pipeline
     * @param executionId Identifier of the execution
     * @param xGwImsOrgId IMS organization ID that the request is being made under.
     * @param authorization Bearer [token] - An access token for the technical account created through integration with Adobe IO
     * @param xApiKey IMS Client ID (API Key) which is subscribed to consume services on console.adobe.io
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getExecution(programId: string, pipelineId: string, executionId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<PipelineExecution>;
    public getExecution(programId: string, pipelineId: string, executionId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<PipelineExecution>>;
    public getExecution(programId: string, pipelineId: string, executionId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<PipelineExecution>>;
    public getExecution(programId: string, pipelineId: string, executionId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {
        if (programId === null || programId === undefined) {
            throw new Error('Required parameter programId was null or undefined when calling getExecution.');
        }
        if (pipelineId === null || pipelineId === undefined) {
            throw new Error('Required parameter pipelineId was null or undefined when calling getExecution.');
        }
        if (executionId === null || executionId === undefined) {
            throw new Error('Required parameter executionId was null or undefined when calling getExecution.');
        }
        if (xGwImsOrgId === null || xGwImsOrgId === undefined) {
            throw new Error('Required parameter xGwImsOrgId was null or undefined when calling getExecution.');
        }
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getExecution.');
        }
        if (xApiKey === null || xApiKey === undefined) {
            throw new Error('Required parameter xApiKey was null or undefined when calling getExecution.');
        }

        let headers = this.defaultHeaders;
        if (xGwImsOrgId !== undefined && xGwImsOrgId !== null) {
            headers = headers.set('x-gw-ims-org-id', String(xGwImsOrgId));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        if (xApiKey !== undefined && xApiKey !== null) {
            headers = headers.set('x-api-key', String(xApiKey));
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<PipelineExecution>(`${this.configuration.basePath}/api/program/${encodeURIComponent(String(programId))}/pipeline/${encodeURIComponent(String(pipelineId))}/execution/${encodeURIComponent(String(executionId))}`,
            {
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List Executions
     * Returns the history of pipeline executions in a newest to oldest order
     * @param programId Identifier of the program.
     * @param pipelineId Identifier of the pipeline
     * @param xGwImsOrgId IMS organization ID that the request is being made under.
     * @param authorization Bearer [token] - An access token for the technical account created through integration with Adobe IO
     * @param xApiKey IMS Client ID (API Key) which is subscribed to consume services on console.adobe.io
     * @param start Pagination start parameter
     * @param limit Pagination limit parameter
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getExecutions(programId: string, pipelineId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, start?: string, limit?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<PipelineExecutionListRepresentation>;
    public getExecutions(programId: string, pipelineId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, start?: string, limit?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<PipelineExecutionListRepresentation>>;
    public getExecutions(programId: string, pipelineId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, start?: string, limit?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<PipelineExecutionListRepresentation>>;
    public getExecutions(programId: string, pipelineId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, start?: string, limit?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {
        if (programId === null || programId === undefined) {
            throw new Error('Required parameter programId was null or undefined when calling getExecutions.');
        }
        if (pipelineId === null || pipelineId === undefined) {
            throw new Error('Required parameter pipelineId was null or undefined when calling getExecutions.');
        }
        if (xGwImsOrgId === null || xGwImsOrgId === undefined) {
            throw new Error('Required parameter xGwImsOrgId was null or undefined when calling getExecutions.');
        }
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getExecutions.');
        }
        if (xApiKey === null || xApiKey === undefined) {
            throw new Error('Required parameter xApiKey was null or undefined when calling getExecutions.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (start !== undefined && start !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>start, 'start');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }

        let headers = this.defaultHeaders;
        if (xGwImsOrgId !== undefined && xGwImsOrgId !== null) {
            headers = headers.set('x-gw-ims-org-id', String(xGwImsOrgId));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        if (xApiKey !== undefined && xApiKey !== null) {
            headers = headers.set('x-api-key', String(xApiKey));
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<PipelineExecutionListRepresentation>(`${this.configuration.basePath}/api/program/${encodeURIComponent(String(programId))}/pipeline/${encodeURIComponent(String(pipelineId))}/executions`,
            {
                params: queryParameters,
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get logs
     * Get the logs associated with a step.
     * @param programId Identifier of the program.
     * @param pipelineId Identifier of the pipeline
     * @param executionId Identifier of the execution
     * @param phaseId Identifier of the phase
     * @param stepId Identifier of the step
     * @param xGwImsOrgId IMS organization ID that the request is being made under.
     * @param authorization Bearer [token] - An access token for the technical account created through integration with Adobe IO
     * @param xApiKey IMS Client ID (API Key) which is subscribed to consume services on console.adobe.io
     * @param file Identifier of the log file
     * @param accept Specify application/json in this header to receive a JSON response. Otherwise, a 307 response code will be returned with a Location header.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStepLogs(programId: string, pipelineId: string, executionId: string, phaseId: string, stepId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, file?: string, accept?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getStepLogs(programId: string, pipelineId: string, executionId: string, phaseId: string, stepId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, file?: string, accept?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getStepLogs(programId: string, pipelineId: string, executionId: string, phaseId: string, stepId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, file?: string, accept?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getStepLogs(programId: string, pipelineId: string, executionId: string, phaseId: string, stepId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, file?: string, accept?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (programId === null || programId === undefined) {
            throw new Error('Required parameter programId was null or undefined when calling getStepLogs.');
        }
        if (pipelineId === null || pipelineId === undefined) {
            throw new Error('Required parameter pipelineId was null or undefined when calling getStepLogs.');
        }
        if (executionId === null || executionId === undefined) {
            throw new Error('Required parameter executionId was null or undefined when calling getStepLogs.');
        }
        if (phaseId === null || phaseId === undefined) {
            throw new Error('Required parameter phaseId was null or undefined when calling getStepLogs.');
        }
        if (stepId === null || stepId === undefined) {
            throw new Error('Required parameter stepId was null or undefined when calling getStepLogs.');
        }
        if (xGwImsOrgId === null || xGwImsOrgId === undefined) {
            throw new Error('Required parameter xGwImsOrgId was null or undefined when calling getStepLogs.');
        }
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getStepLogs.');
        }
        if (xApiKey === null || xApiKey === undefined) {
            throw new Error('Required parameter xApiKey was null or undefined when calling getStepLogs.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (file !== undefined && file !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>file, 'file');
        }

        let headers = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            headers = headers.set('Accept', String(accept));
        }
        if (xGwImsOrgId !== undefined && xGwImsOrgId !== null) {
            headers = headers.set('x-gw-ims-org-id', String(xGwImsOrgId));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        if (xApiKey !== undefined && xApiKey !== null) {
            headers = headers.set('x-api-key', String(xApiKey));
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/api/program/${encodeURIComponent(String(programId))}/pipeline/${encodeURIComponent(String(pipelineId))}/execution/${encodeURIComponent(String(executionId))}/phase/${encodeURIComponent(String(phaseId))}/step/${encodeURIComponent(String(stepId))}/logs`,
            {
                params: queryParameters,
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Start the pipeline
     * Starts the Pipeline. This works only if the pipeline is not already started.
     * @param programId Identifier of the program.
     * @param pipelineId Identifier of the pipeline
     * @param xGwImsOrgId IMS organization ID that the request is being made under.
     * @param authorization Bearer [token] - An access token for the technical account created through integration with Adobe IO
     * @param xApiKey IMS Client ID (API Key) which is subscribed to consume services on console.adobe.io
     * @param contentType Must always be application/json
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public startPipeline(programId: string, pipelineId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, contentType: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public startPipeline(programId: string, pipelineId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, contentType: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public startPipeline(programId: string, pipelineId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, contentType: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public startPipeline(programId: string, pipelineId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, contentType: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (programId === null || programId === undefined) {
            throw new Error('Required parameter programId was null or undefined when calling startPipeline.');
        }
        if (pipelineId === null || pipelineId === undefined) {
            throw new Error('Required parameter pipelineId was null or undefined when calling startPipeline.');
        }
        if (xGwImsOrgId === null || xGwImsOrgId === undefined) {
            throw new Error('Required parameter xGwImsOrgId was null or undefined when calling startPipeline.');
        }
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling startPipeline.');
        }
        if (xApiKey === null || xApiKey === undefined) {
            throw new Error('Required parameter xApiKey was null or undefined when calling startPipeline.');
        }
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling startPipeline.');
        }

        let headers = this.defaultHeaders;
        if (xGwImsOrgId !== undefined && xGwImsOrgId !== null) {
            headers = headers.set('x-gw-ims-org-id', String(xGwImsOrgId));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        if (xApiKey !== undefined && xApiKey !== null) {
            headers = headers.set('x-api-key', String(xApiKey));
        }
        if (contentType !== undefined && contentType !== null) {
            headers = headers.set('Content-Type', String(contentType));
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.put<any>(`${this.configuration.basePath}/api/program/${encodeURIComponent(String(programId))}/pipeline/${encodeURIComponent(String(pipelineId))}/execution`,
            null,
            {
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get step metrics
     * @param programId Identifier of the program.
     * @param pipelineId Identifier of the pipeline
     * @param executionId Identifier of the execution
     * @param phaseId Identifier of the phase
     * @param stepId Identifier of the step
     * @param xGwImsOrgId IMS organization ID that the request is being made under.
     * @param authorization Bearer [token] - An access token for the technical account created through integration with Adobe IO
     * @param xApiKey IMS Client ID (API Key) which is subscribed to consume services on console.adobe.io
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public stepMetric(programId: string, pipelineId: string, executionId: string, phaseId: string, stepId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<PipelineStepMetrics>;
    public stepMetric(programId: string, pipelineId: string, executionId: string, phaseId: string, stepId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<PipelineStepMetrics>>;
    public stepMetric(programId: string, pipelineId: string, executionId: string, phaseId: string, stepId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<PipelineStepMetrics>>;
    public stepMetric(programId: string, pipelineId: string, executionId: string, phaseId: string, stepId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {
        if (programId === null || programId === undefined) {
            throw new Error('Required parameter programId was null or undefined when calling stepMetric.');
        }
        if (pipelineId === null || pipelineId === undefined) {
            throw new Error('Required parameter pipelineId was null or undefined when calling stepMetric.');
        }
        if (executionId === null || executionId === undefined) {
            throw new Error('Required parameter executionId was null or undefined when calling stepMetric.');
        }
        if (phaseId === null || phaseId === undefined) {
            throw new Error('Required parameter phaseId was null or undefined when calling stepMetric.');
        }
        if (stepId === null || stepId === undefined) {
            throw new Error('Required parameter stepId was null or undefined when calling stepMetric.');
        }
        if (xGwImsOrgId === null || xGwImsOrgId === undefined) {
            throw new Error('Required parameter xGwImsOrgId was null or undefined when calling stepMetric.');
        }
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling stepMetric.');
        }
        if (xApiKey === null || xApiKey === undefined) {
            throw new Error('Required parameter xApiKey was null or undefined when calling stepMetric.');
        }

        let headers = this.defaultHeaders;
        if (xGwImsOrgId !== undefined && xGwImsOrgId !== null) {
            headers = headers.set('x-gw-ims-org-id', String(xGwImsOrgId));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        if (xApiKey !== undefined && xApiKey !== null) {
            headers = headers.set('x-api-key', String(xApiKey));
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<PipelineStepMetrics>(`${this.configuration.basePath}/api/program/${encodeURIComponent(String(programId))}/pipeline/${encodeURIComponent(String(pipelineId))}/execution/${encodeURIComponent(String(executionId))}/phase/${encodeURIComponent(String(phaseId))}/step/${encodeURIComponent(String(stepId))}/metrics`,
            {
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get step state
     * @param programId Identifier of the program.
     * @param pipelineId Identifier of the pipeline
     * @param executionId Identifier of the execution
     * @param phaseId Identifier of the phase
     * @param stepId Identifier of the step
     * @param xGwImsOrgId IMS organization ID that the request is being made under.
     * @param authorization Bearer [token] - An access token for the technical account created through integration with Adobe IO
     * @param xApiKey IMS Client ID (API Key) which is subscribed to consume services on console.adobe.io
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public stepState(programId: string, pipelineId: string, executionId: string, phaseId: string, stepId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<PipelineExecutionStepState>;
    public stepState(programId: string, pipelineId: string, executionId: string, phaseId: string, stepId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<PipelineExecutionStepState>>;
    public stepState(programId: string, pipelineId: string, executionId: string, phaseId: string, stepId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<PipelineExecutionStepState>>;
    public stepState(programId: string, pipelineId: string, executionId: string, phaseId: string, stepId: string, xGwImsOrgId: string, authorization: string, xApiKey: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {
        if (programId === null || programId === undefined) {
            throw new Error('Required parameter programId was null or undefined when calling stepState.');
        }
        if (pipelineId === null || pipelineId === undefined) {
            throw new Error('Required parameter pipelineId was null or undefined when calling stepState.');
        }
        if (executionId === null || executionId === undefined) {
            throw new Error('Required parameter executionId was null or undefined when calling stepState.');
        }
        if (phaseId === null || phaseId === undefined) {
            throw new Error('Required parameter phaseId was null or undefined when calling stepState.');
        }
        if (stepId === null || stepId === undefined) {
            throw new Error('Required parameter stepId was null or undefined when calling stepState.');
        }
        if (xGwImsOrgId === null || xGwImsOrgId === undefined) {
            throw new Error('Required parameter xGwImsOrgId was null or undefined when calling stepState.');
        }
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling stepState.');
        }
        if (xApiKey === null || xApiKey === undefined) {
            throw new Error('Required parameter xApiKey was null or undefined when calling stepState.');
        }

        let headers = this.defaultHeaders;
        if (xGwImsOrgId !== undefined && xGwImsOrgId !== null) {
            headers = headers.set('x-gw-ims-org-id', String(xGwImsOrgId));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        if (xApiKey !== undefined && xApiKey !== null) {
            headers = headers.set('x-api-key', String(xApiKey));
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<PipelineExecutionStepState>(`${this.configuration.basePath}/api/program/${encodeURIComponent(String(programId))}/pipeline/${encodeURIComponent(String(pipelineId))}/execution/${encodeURIComponent(String(executionId))}/phase/${encodeURIComponent(String(phaseId))}/step/${encodeURIComponent(String(stepId))}`,
            {
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
