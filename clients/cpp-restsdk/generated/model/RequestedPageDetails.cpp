/**
 * Cloud Manager API
 * This API allows access to Cloud Manager programs, pipelines, and environments by an authorized technical account created through the Adobe I/O Console. The base url for this API is https://cloudmanager.adobe.io, e.g. to get the list of programs for an organization, you would make a GET request to https://cloudmanager.adobe.io/api/programs (with the correct set of headers as described below). This swagger file can be downloaded from https://raw.githubusercontent.com/AdobeDocs/cloudmanager-api-docs/master/swagger-specs/api.yaml.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: opensource@shinesolutions.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 4.3.1-SNAPSHOT.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "RequestedPageDetails.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {




RequestedPageDetails::RequestedPageDetails()
{
    m_Start = 0;
    m_StartIsSet = false;
    m_Limit = 0;
    m_LimitIsSet = false;
    m_OrderBy = utility::conversions::to_string_t("");
    m_OrderByIsSet = false;
    m_PropertyIsSet = false;
    m_Type = utility::conversions::to_string_t("");
    m_TypeIsSet = false;
    m_Next = 0;
    m_NextIsSet = false;
    m_Prev = 0;
    m_PrevIsSet = false;
}

RequestedPageDetails::~RequestedPageDetails()
{
}

void RequestedPageDetails::validate()
{
    // TODO: implement validation
}

web::json::value RequestedPageDetails::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_StartIsSet)
    {
        val[utility::conversions::to_string_t("start")] = ModelBase::toJson(m_Start);
    }
    if(m_LimitIsSet)
    {
        val[utility::conversions::to_string_t("limit")] = ModelBase::toJson(m_Limit);
    }
    if(m_OrderByIsSet)
    {
        val[utility::conversions::to_string_t("orderBy")] = ModelBase::toJson(m_OrderBy);
    }
    if(m_PropertyIsSet)
    {
        val[utility::conversions::to_string_t("property")] = ModelBase::toJson(m_Property);
    }
    if(m_TypeIsSet)
    {
        val[utility::conversions::to_string_t("type")] = ModelBase::toJson(m_Type);
    }
    if(m_NextIsSet)
    {
        val[utility::conversions::to_string_t("next")] = ModelBase::toJson(m_Next);
    }
    if(m_PrevIsSet)
    {
        val[utility::conversions::to_string_t("prev")] = ModelBase::toJson(m_Prev);
    }

    return val;
}

bool RequestedPageDetails::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t("start")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("start"));
        if(!fieldValue.is_null())
        {
            int32_t refVal_start;
            ok &= ModelBase::fromJson(fieldValue, refVal_start);
            setStart(refVal_start);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("limit")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("limit"));
        if(!fieldValue.is_null())
        {
            int32_t refVal_limit;
            ok &= ModelBase::fromJson(fieldValue, refVal_limit);
            setLimit(refVal_limit);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("orderBy")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("orderBy"));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_orderBy;
            ok &= ModelBase::fromJson(fieldValue, refVal_orderBy);
            setOrderBy(refVal_orderBy);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("property")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("property"));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_property;
            ok &= ModelBase::fromJson(fieldValue, refVal_property);
            setProperty(refVal_property);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("type")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("type"));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_type;
            ok &= ModelBase::fromJson(fieldValue, refVal_type);
            setType(refVal_type);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("next")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("next"));
        if(!fieldValue.is_null())
        {
            int32_t refVal_next;
            ok &= ModelBase::fromJson(fieldValue, refVal_next);
            setNext(refVal_next);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("prev")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("prev"));
        if(!fieldValue.is_null())
        {
            int32_t refVal_prev;
            ok &= ModelBase::fromJson(fieldValue, refVal_prev);
            setPrev(refVal_prev);
        }
    }
    return ok;
}

void RequestedPageDetails::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }
    if(m_StartIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("start"), m_Start));
    }
    if(m_LimitIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("limit"), m_Limit));
    }
    if(m_OrderByIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("orderBy"), m_OrderBy));
    }
    if(m_PropertyIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("property"), m_Property));
    }
    if(m_TypeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("type"), m_Type));
    }
    if(m_NextIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("next"), m_Next));
    }
    if(m_PrevIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("prev"), m_Prev));
    }
}

bool RequestedPageDetails::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }

    if(multipart->hasContent(utility::conversions::to_string_t("start")))
    {
        int32_t refVal_start;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("start")), refVal_start );
        setStart(refVal_start);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("limit")))
    {
        int32_t refVal_limit;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("limit")), refVal_limit );
        setLimit(refVal_limit);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("orderBy")))
    {
        utility::string_t refVal_orderBy;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("orderBy")), refVal_orderBy );
        setOrderBy(refVal_orderBy);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("property")))
    {
        std::vector<utility::string_t> refVal_property;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("property")), refVal_property );
        setProperty(refVal_property);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("type")))
    {
        utility::string_t refVal_type;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("type")), refVal_type );
        setType(refVal_type);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("next")))
    {
        int32_t refVal_next;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("next")), refVal_next );
        setNext(refVal_next);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("prev")))
    {
        int32_t refVal_prev;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("prev")), refVal_prev );
        setPrev(refVal_prev);
    }
    return ok;
}

int32_t RequestedPageDetails::getStart() const
{
    return m_Start;
}

void RequestedPageDetails::setStart(int32_t value)
{
    m_Start = value;
    m_StartIsSet = true;
}

bool RequestedPageDetails::startIsSet() const
{
    return m_StartIsSet;
}

void RequestedPageDetails::unsetStart()
{
    m_StartIsSet = false;
}
int32_t RequestedPageDetails::getLimit() const
{
    return m_Limit;
}

void RequestedPageDetails::setLimit(int32_t value)
{
    m_Limit = value;
    m_LimitIsSet = true;
}

bool RequestedPageDetails::limitIsSet() const
{
    return m_LimitIsSet;
}

void RequestedPageDetails::unsetLimit()
{
    m_LimitIsSet = false;
}
utility::string_t RequestedPageDetails::getOrderBy() const
{
    return m_OrderBy;
}

void RequestedPageDetails::setOrderBy(const utility::string_t& value)
{
    m_OrderBy = value;
    m_OrderByIsSet = true;
}

bool RequestedPageDetails::orderByIsSet() const
{
    return m_OrderByIsSet;
}

void RequestedPageDetails::unsetOrderBy()
{
    m_OrderByIsSet = false;
}
std::vector<utility::string_t>& RequestedPageDetails::getProperty()
{
    return m_Property;
}

void RequestedPageDetails::setProperty(const std::vector<utility::string_t>& value)
{
    m_Property = value;
    m_PropertyIsSet = true;
}

bool RequestedPageDetails::propertyIsSet() const
{
    return m_PropertyIsSet;
}

void RequestedPageDetails::unsetProperty()
{
    m_PropertyIsSet = false;
}
utility::string_t RequestedPageDetails::getType() const
{
    return m_Type;
}

void RequestedPageDetails::setType(const utility::string_t& value)
{
    m_Type = value;
    m_TypeIsSet = true;
}

bool RequestedPageDetails::typeIsSet() const
{
    return m_TypeIsSet;
}

void RequestedPageDetails::unsetType()
{
    m_TypeIsSet = false;
}
int32_t RequestedPageDetails::getNext() const
{
    return m_Next;
}

void RequestedPageDetails::setNext(int32_t value)
{
    m_Next = value;
    m_NextIsSet = true;
}

bool RequestedPageDetails::nextIsSet() const
{
    return m_NextIsSet;
}

void RequestedPageDetails::unsetNext()
{
    m_NextIsSet = false;
}
int32_t RequestedPageDetails::getPrev() const
{
    return m_Prev;
}

void RequestedPageDetails::setPrev(int32_t value)
{
    m_Prev = value;
    m_PrevIsSet = true;
}

bool RequestedPageDetails::prevIsSet() const
{
    return m_PrevIsSet;
}

void RequestedPageDetails::unsetPrev()
{
    m_PrevIsSet = false;
}
}
}
}
}


