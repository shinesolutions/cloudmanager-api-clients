/**
 * Cloud Manager API
 * This API allows access to Cloud Manager programs, pipelines, and environments by an authorized technical account created through the Adobe I/O Console. The base url for this API is https://cloudmanager.adobe.io, e.g. to get the list of programs for an organization, you would make a GET request to https://cloudmanager.adobe.io/api/programs (with the correct set of headers as described below). This swagger file can be downloaded from https://raw.githubusercontent.com/AdobeDocs/cloudmanager-api-docs/master/swagger-specs/api.yaml.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: opensource@shinesolutions.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include <QJsonArray>
#include <QJsonDocument>
#include <QJsonObject>
#include <QVariantMap>
#include <QDebug>

#include "OAIHelpers.h"
#include "OAIPipelineExecutionApiRequest.h"

namespace OpenAPI {

OAIPipelineExecutionApiRequest::OAIPipelineExecutionApiRequest(QHttpEngine::Socket *s, QSharedPointer<OAIPipelineExecutionApiHandler> hdl) : QObject(s), socket(s), handler(hdl) {
    auto headers = s->headers();
    for(auto itr = headers.begin(); itr != headers.end(); itr++) {
        requestHeaders.insert(QString(itr.key()), QString(itr.value()));
    }
}

OAIPipelineExecutionApiRequest::~OAIPipelineExecutionApiRequest(){
    disconnect(this, nullptr, nullptr, nullptr);
    qDebug() << "OAIPipelineExecutionApiRequest::~OAIPipelineExecutionApiRequest()";
}

QMap<QString, QString>
OAIPipelineExecutionApiRequest::getRequestHeaders() const {
    return requestHeaders;
}

void OAIPipelineExecutionApiRequest::setResponseHeaders(const QMultiMap<QString, QString>& headers){
    for(auto itr = headers.begin(); itr != headers.end(); ++itr) {
        responseHeaders.insert(itr.key(), itr.value());
    }
}


QHttpEngine::Socket* OAIPipelineExecutionApiRequest::getRawSocket(){
    return socket;
}


void OAIPipelineExecutionApiRequest::advancePipelineExecutionRequest(const QString& program_idstr, const QString& pipeline_idstr, const QString& execution_idstr, const QString& phase_idstr, const QString& step_idstr){
    qDebug() << "/api/program/{programId}/pipeline/{pipelineId}/execution/{executionId}/phase/{phaseId}/step/{stepId}/advance";
    connect(this, &OAIPipelineExecutionApiRequest::advancePipelineExecution, handler.data(), &OAIPipelineExecutionApiHandler::advancePipelineExecution);

    
    QString program_id;
    fromStringValue(program_idstr, program_id);
        QString pipeline_id;
    fromStringValue(pipeline_idstr, pipeline_id);
        QString execution_id;
    fromStringValue(execution_idstr, execution_id);
        QString phase_id;
    fromStringValue(phase_idstr, phase_id);
        QString step_id;
    fromStringValue(step_idstr, step_id);
    
    QString x_gw_ims_org_id;
    if(socket->headers().keys().contains("x_gw_ims_org_id")){
        fromStringValue(socket->queryString().value("x_gw_ims_org_id"), x_gw_ims_org_id);
    }
    
    QString authorization;
    if(socket->headers().keys().contains("authorization")){
        fromStringValue(socket->queryString().value("authorization"), authorization);
    }
    
    QString x_api_key;
    if(socket->headers().keys().contains("x_api_key")){
        fromStringValue(socket->queryString().value("x_api_key"), x_api_key);
    }
    
    QString content_type;
    if(socket->headers().keys().contains("content_type")){
        fromStringValue(socket->queryString().value("content_type"), content_type);
    }
     
    
    OAIObject body;
    QJsonDocument resObject = QJsonDocument::fromJson(socket->readAll());
    ::OpenAPI::fromJsonValue(body, resObject.object());
    

    emit advancePipelineExecution(program_id, pipeline_id, execution_id, phase_id, step_id, x_gw_ims_org_id, authorization, x_api_key, content_type, body);
}


void OAIPipelineExecutionApiRequest::cancelPipelineExecutionStepRequest(const QString& program_idstr, const QString& pipeline_idstr, const QString& execution_idstr, const QString& phase_idstr, const QString& step_idstr){
    qDebug() << "/api/program/{programId}/pipeline/{pipelineId}/execution/{executionId}/phase/{phaseId}/step/{stepId}/cancel";
    connect(this, &OAIPipelineExecutionApiRequest::cancelPipelineExecutionStep, handler.data(), &OAIPipelineExecutionApiHandler::cancelPipelineExecutionStep);

    
    QString program_id;
    fromStringValue(program_idstr, program_id);
        QString pipeline_id;
    fromStringValue(pipeline_idstr, pipeline_id);
        QString execution_id;
    fromStringValue(execution_idstr, execution_id);
        QString phase_id;
    fromStringValue(phase_idstr, phase_id);
        QString step_id;
    fromStringValue(step_idstr, step_id);
    
    QString x_gw_ims_org_id;
    if(socket->headers().keys().contains("x_gw_ims_org_id")){
        fromStringValue(socket->queryString().value("x_gw_ims_org_id"), x_gw_ims_org_id);
    }
    
    QString authorization;
    if(socket->headers().keys().contains("authorization")){
        fromStringValue(socket->queryString().value("authorization"), authorization);
    }
    
    QString x_api_key;
    if(socket->headers().keys().contains("x_api_key")){
        fromStringValue(socket->queryString().value("x_api_key"), x_api_key);
    }
    
    QString content_type;
    if(socket->headers().keys().contains("content_type")){
        fromStringValue(socket->queryString().value("content_type"), content_type);
    }
     
    
    OAIObject body;
    QJsonDocument resObject = QJsonDocument::fromJson(socket->readAll());
    ::OpenAPI::fromJsonValue(body, resObject.object());
    

    emit cancelPipelineExecutionStep(program_id, pipeline_id, execution_id, phase_id, step_id, x_gw_ims_org_id, authorization, x_api_key, content_type, body);
}


void OAIPipelineExecutionApiRequest::getCurrentExecutionRequest(const QString& program_idstr, const QString& pipeline_idstr){
    qDebug() << "/api/program/{programId}/pipeline/{pipelineId}/execution";
    connect(this, &OAIPipelineExecutionApiRequest::getCurrentExecution, handler.data(), &OAIPipelineExecutionApiHandler::getCurrentExecution);

    
    QString program_id;
    fromStringValue(program_idstr, program_id);
        QString pipeline_id;
    fromStringValue(pipeline_idstr, pipeline_id);
    
    QString x_gw_ims_org_id;
    if(socket->headers().keys().contains("x_gw_ims_org_id")){
        fromStringValue(socket->queryString().value("x_gw_ims_org_id"), x_gw_ims_org_id);
    }
    
    QString authorization;
    if(socket->headers().keys().contains("authorization")){
        fromStringValue(socket->queryString().value("authorization"), authorization);
    }
    
    QString x_api_key;
    if(socket->headers().keys().contains("x_api_key")){
        fromStringValue(socket->queryString().value("x_api_key"), x_api_key);
    }
    

    emit getCurrentExecution(program_id, pipeline_id, x_gw_ims_org_id, authorization, x_api_key);
}


void OAIPipelineExecutionApiRequest::getExecutionRequest(const QString& program_idstr, const QString& pipeline_idstr, const QString& execution_idstr){
    qDebug() << "/api/program/{programId}/pipeline/{pipelineId}/execution/{executionId}";
    connect(this, &OAIPipelineExecutionApiRequest::getExecution, handler.data(), &OAIPipelineExecutionApiHandler::getExecution);

    
    QString program_id;
    fromStringValue(program_idstr, program_id);
        QString pipeline_id;
    fromStringValue(pipeline_idstr, pipeline_id);
        QString execution_id;
    fromStringValue(execution_idstr, execution_id);
    
    QString x_gw_ims_org_id;
    if(socket->headers().keys().contains("x_gw_ims_org_id")){
        fromStringValue(socket->queryString().value("x_gw_ims_org_id"), x_gw_ims_org_id);
    }
    
    QString authorization;
    if(socket->headers().keys().contains("authorization")){
        fromStringValue(socket->queryString().value("authorization"), authorization);
    }
    
    QString x_api_key;
    if(socket->headers().keys().contains("x_api_key")){
        fromStringValue(socket->queryString().value("x_api_key"), x_api_key);
    }
    

    emit getExecution(program_id, pipeline_id, execution_id, x_gw_ims_org_id, authorization, x_api_key);
}


void OAIPipelineExecutionApiRequest::getExecutionsRequest(const QString& program_idstr, const QString& pipeline_idstr){
    qDebug() << "/api/program/{programId}/pipeline/{pipelineId}/executions";
    connect(this, &OAIPipelineExecutionApiRequest::getExecutions, handler.data(), &OAIPipelineExecutionApiHandler::getExecutions);

    
    QString start;
    if(socket->queryString().keys().contains("start")){
        fromStringValue(socket->queryString().value("start"), start);
    }
    
    qint32 limit;
    if(socket->queryString().keys().contains("limit")){
        fromStringValue(socket->queryString().value("limit"), limit);
    }
    
    QString program_id;
    fromStringValue(program_idstr, program_id);
        QString pipeline_id;
    fromStringValue(pipeline_idstr, pipeline_id);
    
    QString x_gw_ims_org_id;
    if(socket->headers().keys().contains("x_gw_ims_org_id")){
        fromStringValue(socket->queryString().value("x_gw_ims_org_id"), x_gw_ims_org_id);
    }
    
    QString authorization;
    if(socket->headers().keys().contains("authorization")){
        fromStringValue(socket->queryString().value("authorization"), authorization);
    }
    
    QString x_api_key;
    if(socket->headers().keys().contains("x_api_key")){
        fromStringValue(socket->queryString().value("x_api_key"), x_api_key);
    }
    

    emit getExecutions(program_id, pipeline_id, x_gw_ims_org_id, authorization, x_api_key, start, limit);
}


void OAIPipelineExecutionApiRequest::getStepLogsRequest(const QString& program_idstr, const QString& pipeline_idstr, const QString& execution_idstr, const QString& phase_idstr, const QString& step_idstr){
    qDebug() << "/api/program/{programId}/pipeline/{pipelineId}/execution/{executionId}/phase/{phaseId}/step/{stepId}/logs";
    connect(this, &OAIPipelineExecutionApiRequest::getStepLogs, handler.data(), &OAIPipelineExecutionApiHandler::getStepLogs);

    
    QString file;
    if(socket->queryString().keys().contains("file")){
        fromStringValue(socket->queryString().value("file"), file);
    }
    
    QString program_id;
    fromStringValue(program_idstr, program_id);
        QString pipeline_id;
    fromStringValue(pipeline_idstr, pipeline_id);
        QString execution_id;
    fromStringValue(execution_idstr, execution_id);
        QString phase_id;
    fromStringValue(phase_idstr, phase_id);
        QString step_id;
    fromStringValue(step_idstr, step_id);
    
    QString accept;
    if(socket->headers().keys().contains("accept")){
        fromStringValue(socket->queryString().value("accept"), accept);
    }
    
    QString x_gw_ims_org_id;
    if(socket->headers().keys().contains("x_gw_ims_org_id")){
        fromStringValue(socket->queryString().value("x_gw_ims_org_id"), x_gw_ims_org_id);
    }
    
    QString authorization;
    if(socket->headers().keys().contains("authorization")){
        fromStringValue(socket->queryString().value("authorization"), authorization);
    }
    
    QString x_api_key;
    if(socket->headers().keys().contains("x_api_key")){
        fromStringValue(socket->queryString().value("x_api_key"), x_api_key);
    }
    

    emit getStepLogs(program_id, pipeline_id, execution_id, phase_id, step_id, x_gw_ims_org_id, authorization, x_api_key, file, accept);
}


void OAIPipelineExecutionApiRequest::startPipelineRequest(const QString& program_idstr, const QString& pipeline_idstr){
    qDebug() << "/api/program/{programId}/pipeline/{pipelineId}/execution";
    connect(this, &OAIPipelineExecutionApiRequest::startPipeline, handler.data(), &OAIPipelineExecutionApiHandler::startPipeline);

    
    QString program_id;
    fromStringValue(program_idstr, program_id);
        QString pipeline_id;
    fromStringValue(pipeline_idstr, pipeline_id);
    
    QString x_gw_ims_org_id;
    if(socket->headers().keys().contains("x_gw_ims_org_id")){
        fromStringValue(socket->queryString().value("x_gw_ims_org_id"), x_gw_ims_org_id);
    }
    
    QString authorization;
    if(socket->headers().keys().contains("authorization")){
        fromStringValue(socket->queryString().value("authorization"), authorization);
    }
    
    QString x_api_key;
    if(socket->headers().keys().contains("x_api_key")){
        fromStringValue(socket->queryString().value("x_api_key"), x_api_key);
    }
    
    QString content_type;
    if(socket->headers().keys().contains("content_type")){
        fromStringValue(socket->queryString().value("content_type"), content_type);
    }
    

    emit startPipeline(program_id, pipeline_id, x_gw_ims_org_id, authorization, x_api_key, content_type);
}


void OAIPipelineExecutionApiRequest::stepMetricRequest(const QString& program_idstr, const QString& pipeline_idstr, const QString& execution_idstr, const QString& phase_idstr, const QString& step_idstr){
    qDebug() << "/api/program/{programId}/pipeline/{pipelineId}/execution/{executionId}/phase/{phaseId}/step/{stepId}/metrics";
    connect(this, &OAIPipelineExecutionApiRequest::stepMetric, handler.data(), &OAIPipelineExecutionApiHandler::stepMetric);

    
    QString program_id;
    fromStringValue(program_idstr, program_id);
        QString pipeline_id;
    fromStringValue(pipeline_idstr, pipeline_id);
        QString execution_id;
    fromStringValue(execution_idstr, execution_id);
        QString phase_id;
    fromStringValue(phase_idstr, phase_id);
        QString step_id;
    fromStringValue(step_idstr, step_id);
    
    QString x_gw_ims_org_id;
    if(socket->headers().keys().contains("x_gw_ims_org_id")){
        fromStringValue(socket->queryString().value("x_gw_ims_org_id"), x_gw_ims_org_id);
    }
    
    QString authorization;
    if(socket->headers().keys().contains("authorization")){
        fromStringValue(socket->queryString().value("authorization"), authorization);
    }
    
    QString x_api_key;
    if(socket->headers().keys().contains("x_api_key")){
        fromStringValue(socket->queryString().value("x_api_key"), x_api_key);
    }
    

    emit stepMetric(program_id, pipeline_id, execution_id, phase_id, step_id, x_gw_ims_org_id, authorization, x_api_key);
}


void OAIPipelineExecutionApiRequest::stepStateRequest(const QString& program_idstr, const QString& pipeline_idstr, const QString& execution_idstr, const QString& phase_idstr, const QString& step_idstr){
    qDebug() << "/api/program/{programId}/pipeline/{pipelineId}/execution/{executionId}/phase/{phaseId}/step/{stepId}";
    connect(this, &OAIPipelineExecutionApiRequest::stepState, handler.data(), &OAIPipelineExecutionApiHandler::stepState);

    
    QString program_id;
    fromStringValue(program_idstr, program_id);
        QString pipeline_id;
    fromStringValue(pipeline_idstr, pipeline_id);
        QString execution_id;
    fromStringValue(execution_idstr, execution_id);
        QString phase_id;
    fromStringValue(phase_idstr, phase_id);
        QString step_id;
    fromStringValue(step_idstr, step_id);
    
    QString x_gw_ims_org_id;
    if(socket->headers().keys().contains("x_gw_ims_org_id")){
        fromStringValue(socket->queryString().value("x_gw_ims_org_id"), x_gw_ims_org_id);
    }
    
    QString authorization;
    if(socket->headers().keys().contains("authorization")){
        fromStringValue(socket->queryString().value("authorization"), authorization);
    }
    
    QString x_api_key;
    if(socket->headers().keys().contains("x_api_key")){
        fromStringValue(socket->queryString().value("x_api_key"), x_api_key);
    }
    

    emit stepState(program_id, pipeline_id, execution_id, phase_id, step_id, x_gw_ims_org_id, authorization, x_api_key);
}



void OAIPipelineExecutionApiRequest::advancePipelineExecutionResponse(){
    writeResponseHeaders();
    socket->setStatusCode(QHttpEngine::Socket::OK);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIPipelineExecutionApiRequest::cancelPipelineExecutionStepResponse(){
    writeResponseHeaders();
    socket->setStatusCode(QHttpEngine::Socket::OK);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIPipelineExecutionApiRequest::getCurrentExecutionResponse(const OAIPipelineExecution& res){
    writeResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIPipelineExecutionApiRequest::getExecutionResponse(const OAIPipelineExecution& res){
    writeResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIPipelineExecutionApiRequest::getExecutionsResponse(const OAIPipelineExecutionListRepresentation& res){
    writeResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIPipelineExecutionApiRequest::getStepLogsResponse(){
    writeResponseHeaders();
    socket->setStatusCode(QHttpEngine::Socket::OK);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIPipelineExecutionApiRequest::startPipelineResponse(){
    writeResponseHeaders();
    socket->setStatusCode(QHttpEngine::Socket::OK);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIPipelineExecutionApiRequest::stepMetricResponse(const OAIPipelineStepMetrics& res){
    writeResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIPipelineExecutionApiRequest::stepStateResponse(const OAIPipelineExecutionStepState& res){
    writeResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}


void OAIPipelineExecutionApiRequest::advancePipelineExecutionError(QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    writeResponseHeaders();
    socket->setStatusCode(QHttpEngine::Socket::NotFound);
    socket->write(error_str.toUtf8());
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIPipelineExecutionApiRequest::cancelPipelineExecutionStepError(QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    writeResponseHeaders();
    socket->setStatusCode(QHttpEngine::Socket::NotFound);
    socket->write(error_str.toUtf8());
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIPipelineExecutionApiRequest::getCurrentExecutionError(const OAIPipelineExecution& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    writeResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIPipelineExecutionApiRequest::getExecutionError(const OAIPipelineExecution& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    writeResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIPipelineExecutionApiRequest::getExecutionsError(const OAIPipelineExecutionListRepresentation& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    writeResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIPipelineExecutionApiRequest::getStepLogsError(QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    writeResponseHeaders();
    socket->setStatusCode(QHttpEngine::Socket::NotFound);
    socket->write(error_str.toUtf8());
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIPipelineExecutionApiRequest::startPipelineError(QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    writeResponseHeaders();
    socket->setStatusCode(QHttpEngine::Socket::NotFound);
    socket->write(error_str.toUtf8());
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIPipelineExecutionApiRequest::stepMetricError(const OAIPipelineStepMetrics& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    writeResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIPipelineExecutionApiRequest::stepStateError(const OAIPipelineExecutionStepState& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    writeResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}


void OAIPipelineExecutionApiRequest::sendCustomResponse(QByteArray & res, QNetworkReply::NetworkError error_type){
    Q_UNUSED(error_type); // TODO
    socket->write(res);
    if(socket->isOpen()){
        socket->close();
    }    
}

void OAIPipelineExecutionApiRequest::sendCustomResponse(QIODevice *res, QNetworkReply::NetworkError error_type){
    Q_UNUSED(error_type);  // TODO
    socket->write(res->readAll());
    if(socket->isOpen()){
        socket->close();
    }
}

}
