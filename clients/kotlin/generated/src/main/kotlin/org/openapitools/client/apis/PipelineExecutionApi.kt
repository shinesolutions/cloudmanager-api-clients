/**
* Cloud Manager API
* This API allows access to Cloud Manager programs, pipelines, and environments by an authorized technical account created through the Adobe I/O Console. The base url for this API is https://cloudmanager.adobe.io, e.g. to get the list of programs for an organization, you would make a GET request to https://cloudmanager.adobe.io/api/programs (with the correct set of headers as described below). This swagger file can be downloaded from https://raw.githubusercontent.com/AdobeDocs/cloudmanager-api-docs/master/swagger-specs/api.yaml.
*
* The version of the OpenAPI document: 1.0.0
* Contact: opensource@shinesolutions.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/
package org.openapitools.client.apis

import org.openapitools.client.models.PipelineExecution
import org.openapitools.client.models.PipelineExecutionListRepresentation
import org.openapitools.client.models.PipelineExecutionStepState
import org.openapitools.client.models.PipelineStepMetrics

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class PipelineExecutionApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("org.openapitools.client.baseUrl", "https://cloudmanager.adobe.io")
        }
    }

    /**
    * Advance
    * Post to this url in order to advance the current pipeline execution, if paused and waiting for user interaction. Link is present in output only in that case. The input depends on the actual reason for which the pipeline execution stopped.
    * @param programId Identifier of the program. 
    * @param pipelineId Identifier of the pipeline 
    * @param executionId Identifier of the execution 
    * @param phaseId Identifier of the phase 
    * @param stepId Identifier of the step 
    * @param xMinusGwMinusImsMinusOrgMinusId IMS organization ID that the request is being made under. 
    * @param authorization Bearer [token] - An access token for the technical account created through integration with Adobe IO 
    * @param xMinusApiMinusKey IMS Client ID (API Key) which is subscribed to consume services on console.adobe.io 
    * @param contentMinusType Must always be application/json 
    * @param body Input for advance. See documentation for details. 
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun advancePipelineExecution(programId: kotlin.String, pipelineId: kotlin.String, executionId: kotlin.String, phaseId: kotlin.String, stepId: kotlin.String, xMinusGwMinusImsMinusOrgMinusId: kotlin.String, authorization: kotlin.String, xMinusApiMinusKey: kotlin.String, contentMinusType: kotlin.String, body: kotlin.Any) : Unit {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("x-gw-ims-org-id" to xMinusGwMinusImsMinusOrgMinusId.toString(), "Authorization" to authorization.toString(), "x-api-key" to xMinusApiMinusKey.toString(), "Content-Type" to contentMinusType.toString())
        val localVariableConfig = RequestConfig(
            RequestMethod.PUT,
            "/api/program/{programId}/pipeline/{pipelineId}/execution/{executionId}/phase/{phaseId}/step/{stepId}/advance".replace("{"+"programId"+"}", "$programId").replace("{"+"pipelineId"+"}", "$pipelineId").replace("{"+"executionId"+"}", "$executionId").replace("{"+"phaseId"+"}", "$phaseId").replace("{"+"stepId"+"}", "$stepId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Cancel
    * Post to this url in order to cancel the current pipeline execution. Link is present in output only in that case.
    * @param programId Identifier of the program. 
    * @param pipelineId Identifier of the pipeline 
    * @param executionId Identifier of the execution 
    * @param phaseId Identifier of the phase 
    * @param stepId Identifier of the step 
    * @param xMinusGwMinusImsMinusOrgMinusId IMS organization ID that the request is being made under. 
    * @param authorization Bearer [token] - An access token for the technical account created through integration with Adobe IO 
    * @param xMinusApiMinusKey IMS Client ID (API Key) which is subscribed to consume services on console.adobe.io 
    * @param contentMinusType Must always be application/json 
    * @param body Input for advance. See documentation for details. 
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cancelPipelineExecutionStep(programId: kotlin.String, pipelineId: kotlin.String, executionId: kotlin.String, phaseId: kotlin.String, stepId: kotlin.String, xMinusGwMinusImsMinusOrgMinusId: kotlin.String, authorization: kotlin.String, xMinusApiMinusKey: kotlin.String, contentMinusType: kotlin.String, body: kotlin.Any) : Unit {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("x-gw-ims-org-id" to xMinusGwMinusImsMinusOrgMinusId.toString(), "Authorization" to authorization.toString(), "x-api-key" to xMinusApiMinusKey.toString(), "Content-Type" to contentMinusType.toString())
        val localVariableConfig = RequestConfig(
            RequestMethod.PUT,
            "/api/program/{programId}/pipeline/{pipelineId}/execution/{executionId}/phase/{phaseId}/step/{stepId}/cancel".replace("{"+"programId"+"}", "$programId").replace("{"+"pipelineId"+"}", "$pipelineId").replace("{"+"executionId"+"}", "$executionId").replace("{"+"phaseId"+"}", "$phaseId").replace("{"+"stepId"+"}", "$stepId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get current pipeline execution
    * Returns current pipeline execution if any.
    * @param programId Identifier of the program. 
    * @param pipelineId Identifier of the pipeline 
    * @param xMinusGwMinusImsMinusOrgMinusId IMS organization ID that the request is being made under. 
    * @param authorization Bearer [token] - An access token for the technical account created through integration with Adobe IO 
    * @param xMinusApiMinusKey IMS Client ID (API Key) which is subscribed to consume services on console.adobe.io 
    * @return PipelineExecution
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCurrentExecution(programId: kotlin.String, pipelineId: kotlin.String, xMinusGwMinusImsMinusOrgMinusId: kotlin.String, authorization: kotlin.String, xMinusApiMinusKey: kotlin.String) : PipelineExecution {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("x-gw-ims-org-id" to xMinusGwMinusImsMinusOrgMinusId.toString(), "Authorization" to authorization.toString(), "x-api-key" to xMinusApiMinusKey.toString())
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/api/program/{programId}/pipeline/{pipelineId}/execution".replace("{"+"programId"+"}", "$programId").replace("{"+"pipelineId"+"}", "$pipelineId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<PipelineExecution>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PipelineExecution
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get pipeline execution
    * Returns a pipeline execution by id
    * @param programId Identifier of the program. 
    * @param pipelineId Identifier of the pipeline 
    * @param executionId Identifier of the execution 
    * @param xMinusGwMinusImsMinusOrgMinusId IMS organization ID that the request is being made under. 
    * @param authorization Bearer [token] - An access token for the technical account created through integration with Adobe IO 
    * @param xMinusApiMinusKey IMS Client ID (API Key) which is subscribed to consume services on console.adobe.io 
    * @return PipelineExecution
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getExecution(programId: kotlin.String, pipelineId: kotlin.String, executionId: kotlin.String, xMinusGwMinusImsMinusOrgMinusId: kotlin.String, authorization: kotlin.String, xMinusApiMinusKey: kotlin.String) : PipelineExecution {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("x-gw-ims-org-id" to xMinusGwMinusImsMinusOrgMinusId.toString(), "Authorization" to authorization.toString(), "x-api-key" to xMinusApiMinusKey.toString())
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/api/program/{programId}/pipeline/{pipelineId}/execution/{executionId}".replace("{"+"programId"+"}", "$programId").replace("{"+"pipelineId"+"}", "$pipelineId").replace("{"+"executionId"+"}", "$executionId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<PipelineExecution>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PipelineExecution
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * List Executions
    * Returns the history of pipeline executions in a newest to oldest order
    * @param programId Identifier of the program. 
    * @param pipelineId Identifier of the pipeline 
    * @param xMinusGwMinusImsMinusOrgMinusId IMS organization ID that the request is being made under. 
    * @param authorization Bearer [token] - An access token for the technical account created through integration with Adobe IO 
    * @param xMinusApiMinusKey IMS Client ID (API Key) which is subscribed to consume services on console.adobe.io 
    * @param start Pagination start parameter (optional)
    * @param limit Pagination limit parameter (optional)
    * @return PipelineExecutionListRepresentation
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getExecutions(programId: kotlin.String, pipelineId: kotlin.String, xMinusGwMinusImsMinusOrgMinusId: kotlin.String, authorization: kotlin.String, xMinusApiMinusKey: kotlin.String, start: kotlin.String?, limit: kotlin.Int?) : PipelineExecutionListRepresentation {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("x-gw-ims-org-id" to xMinusGwMinusImsMinusOrgMinusId.toString(), "Authorization" to authorization.toString(), "x-api-key" to xMinusApiMinusKey.toString())
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/api/program/{programId}/pipeline/{pipelineId}/executions".replace("{"+"programId"+"}", "$programId").replace("{"+"pipelineId"+"}", "$pipelineId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<PipelineExecutionListRepresentation>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PipelineExecutionListRepresentation
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get logs
    * Get the logs associated with a step.
    * @param programId Identifier of the program. 
    * @param pipelineId Identifier of the pipeline 
    * @param executionId Identifier of the execution 
    * @param phaseId Identifier of the phase 
    * @param stepId Identifier of the step 
    * @param xMinusGwMinusImsMinusOrgMinusId IMS organization ID that the request is being made under. 
    * @param authorization Bearer [token] - An access token for the technical account created through integration with Adobe IO 
    * @param xMinusApiMinusKey IMS Client ID (API Key) which is subscribed to consume services on console.adobe.io 
    * @param file Identifier of the log file (optional)
    * @param accept Specify application/json in this header to receive a JSON response. Otherwise, a 307 response code will be returned with a Location header. (optional)
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStepLogs(programId: kotlin.String, pipelineId: kotlin.String, executionId: kotlin.String, phaseId: kotlin.String, stepId: kotlin.String, xMinusGwMinusImsMinusOrgMinusId: kotlin.String, authorization: kotlin.String, xMinusApiMinusKey: kotlin.String, file: kotlin.String?, accept: kotlin.String?) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (file != null) {
                    put("file", listOf(file.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Accept" to accept.toString(), "x-gw-ims-org-id" to xMinusGwMinusImsMinusOrgMinusId.toString(), "Authorization" to authorization.toString(), "x-api-key" to xMinusApiMinusKey.toString())
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/api/program/{programId}/pipeline/{pipelineId}/execution/{executionId}/phase/{phaseId}/step/{stepId}/logs".replace("{"+"programId"+"}", "$programId").replace("{"+"pipelineId"+"}", "$pipelineId").replace("{"+"executionId"+"}", "$executionId").replace("{"+"phaseId"+"}", "$phaseId").replace("{"+"stepId"+"}", "$stepId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Start the pipeline
    * Starts the Pipeline. This works only if the pipeline is not already started.
    * @param programId Identifier of the program. 
    * @param pipelineId Identifier of the pipeline 
    * @param xMinusGwMinusImsMinusOrgMinusId IMS organization ID that the request is being made under. 
    * @param authorization Bearer [token] - An access token for the technical account created through integration with Adobe IO 
    * @param xMinusApiMinusKey IMS Client ID (API Key) which is subscribed to consume services on console.adobe.io 
    * @param contentMinusType Must always be application/json 
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun startPipeline(programId: kotlin.String, pipelineId: kotlin.String, xMinusGwMinusImsMinusOrgMinusId: kotlin.String, authorization: kotlin.String, xMinusApiMinusKey: kotlin.String, contentMinusType: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("x-gw-ims-org-id" to xMinusGwMinusImsMinusOrgMinusId.toString(), "Authorization" to authorization.toString(), "x-api-key" to xMinusApiMinusKey.toString(), "Content-Type" to contentMinusType.toString())
        val localVariableConfig = RequestConfig(
            RequestMethod.PUT,
            "/api/program/{programId}/pipeline/{pipelineId}/execution".replace("{"+"programId"+"}", "$programId").replace("{"+"pipelineId"+"}", "$pipelineId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get step metrics
    * 
    * @param programId Identifier of the program. 
    * @param pipelineId Identifier of the pipeline 
    * @param executionId Identifier of the execution 
    * @param phaseId Identifier of the phase 
    * @param stepId Identifier of the step 
    * @param xMinusGwMinusImsMinusOrgMinusId IMS organization ID that the request is being made under. 
    * @param authorization Bearer [token] - An access token for the technical account created through integration with Adobe IO 
    * @param xMinusApiMinusKey IMS Client ID (API Key) which is subscribed to consume services on console.adobe.io 
    * @return PipelineStepMetrics
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stepMetric(programId: kotlin.String, pipelineId: kotlin.String, executionId: kotlin.String, phaseId: kotlin.String, stepId: kotlin.String, xMinusGwMinusImsMinusOrgMinusId: kotlin.String, authorization: kotlin.String, xMinusApiMinusKey: kotlin.String) : PipelineStepMetrics {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("x-gw-ims-org-id" to xMinusGwMinusImsMinusOrgMinusId.toString(), "Authorization" to authorization.toString(), "x-api-key" to xMinusApiMinusKey.toString())
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/api/program/{programId}/pipeline/{pipelineId}/execution/{executionId}/phase/{phaseId}/step/{stepId}/metrics".replace("{"+"programId"+"}", "$programId").replace("{"+"pipelineId"+"}", "$pipelineId").replace("{"+"executionId"+"}", "$executionId").replace("{"+"phaseId"+"}", "$phaseId").replace("{"+"stepId"+"}", "$stepId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<PipelineStepMetrics>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PipelineStepMetrics
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get step state
    * 
    * @param programId Identifier of the program. 
    * @param pipelineId Identifier of the pipeline 
    * @param executionId Identifier of the execution 
    * @param phaseId Identifier of the phase 
    * @param stepId Identifier of the step 
    * @param xMinusGwMinusImsMinusOrgMinusId IMS organization ID that the request is being made under. 
    * @param authorization Bearer [token] - An access token for the technical account created through integration with Adobe IO 
    * @param xMinusApiMinusKey IMS Client ID (API Key) which is subscribed to consume services on console.adobe.io 
    * @return PipelineExecutionStepState
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stepState(programId: kotlin.String, pipelineId: kotlin.String, executionId: kotlin.String, phaseId: kotlin.String, stepId: kotlin.String, xMinusGwMinusImsMinusOrgMinusId: kotlin.String, authorization: kotlin.String, xMinusApiMinusKey: kotlin.String) : PipelineExecutionStepState {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("x-gw-ims-org-id" to xMinusGwMinusImsMinusOrgMinusId.toString(), "Authorization" to authorization.toString(), "x-api-key" to xMinusApiMinusKey.toString())
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/api/program/{programId}/pipeline/{pipelineId}/execution/{executionId}/phase/{phaseId}/step/{stepId}".replace("{"+"programId"+"}", "$programId").replace("{"+"pipelineId"+"}", "$pipelineId").replace("{"+"executionId"+"}", "$executionId").replace("{"+"phaseId"+"}", "$phaseId").replace("{"+"stepId"+"}", "$stepId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<PipelineExecutionStepState>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PipelineExecutionStepState
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

}
