{-
   Cloud Manager API

   This API allows access to Cloud Manager programs, pipelines, and environments by an authorized technical account created through the Adobe I/O Console. The base url for this API is https://cloudmanager.adobe.io, e.g. to get the list of programs for an organization, you would make a GET request to https://cloudmanager.adobe.io/api/programs (with the correct set of headers as described below). This swagger file can be downloaded from https://raw.githubusercontent.com/AdobeDocs/cloudmanager-api-docs/master/swagger-specs/api.yaml.

   OpenAPI Version: 3.0.3
   Cloud Manager API API version: 1.0.0
   Contact: opensource@shinesolutions.com
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : CloudManager.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module CloudManager.Model where

import CloudManager.Core
import CloudManager.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** Authorization
newtype Authorization = Authorization { unAuthorization :: Text } deriving (P.Eq, P.Show)

-- ** Body
newtype Body = Body { unBody :: A.Value } deriving (P.Eq, P.Show, A.ToJSON)

-- ** BodyVariable
newtype BodyVariable = BodyVariable { unBodyVariable :: [Variable] } deriving (P.Eq, P.Show, A.ToJSON)

-- ** Days
newtype Days = Days { unDays :: Int } deriving (P.Eq, P.Show)

-- ** EnvironmentId
newtype EnvironmentId = EnvironmentId { unEnvironmentId :: Text } deriving (P.Eq, P.Show)

-- ** ExecutionId
newtype ExecutionId = ExecutionId { unExecutionId :: Text } deriving (P.Eq, P.Show)

-- ** File
newtype File = File { unFile :: Text } deriving (P.Eq, P.Show)

-- ** Limit
newtype Limit = Limit { unLimit :: Int } deriving (P.Eq, P.Show)

-- ** Name
newtype Name = Name { unName :: [Text] } deriving (P.Eq, P.Show)

-- ** NameText
newtype NameText = NameText { unNameText :: Text } deriving (P.Eq, P.Show)

-- ** ParamAccept
newtype ParamAccept = ParamAccept { unParamAccept :: Text } deriving (P.Eq, P.Show)

-- ** ParamContentType
newtype ParamContentType = ParamContentType { unParamContentType :: Text } deriving (P.Eq, P.Show)

-- ** ParamDate
newtype ParamDate = ParamDate { unParamDate :: Text } deriving (P.Eq, P.Show)

-- ** ParamType
newtype ParamType = ParamType { unParamType :: E'Type2 } deriving (P.Eq, P.Show)

-- ** PhaseId
newtype PhaseId = PhaseId { unPhaseId :: Text } deriving (P.Eq, P.Show)

-- ** PipelineId
newtype PipelineId = PipelineId { unPipelineId :: Text } deriving (P.Eq, P.Show)

-- ** ProgramId
newtype ProgramId = ProgramId { unProgramId :: Text } deriving (P.Eq, P.Show)

-- ** RepositoryId
newtype RepositoryId = RepositoryId { unRepositoryId :: Text } deriving (P.Eq, P.Show)

-- ** Service
newtype Service = Service { unService :: [Text] } deriving (P.Eq, P.Show)

-- ** ServiceText
newtype ServiceText = ServiceText { unServiceText :: Text } deriving (P.Eq, P.Show)

-- ** Start
newtype Start = Start { unStart :: Text } deriving (P.Eq, P.Show)

-- ** StepId
newtype StepId = StepId { unStepId :: Text } deriving (P.Eq, P.Show)

-- ** XApiKey
newtype XApiKey = XApiKey { unXApiKey :: Text } deriving (P.Eq, P.Show)

-- ** XGwImsOrgId
newtype XGwImsOrgId = XGwImsOrgId { unXGwImsOrgId :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** BadRequestError
-- | BadRequestError
-- A Bad Request response error.
data BadRequestError = BadRequestError
  { badRequestErrorStatus :: !(Maybe Int) -- ^ "status" - HTTP status code of the response.
  , badRequestErrorType :: !(Maybe Text) -- ^ "type" - Error type identifier.
  , badRequestErrorTitle :: !(Maybe Text) -- ^ "title" - A short summary of the error.
  , badRequestErrorMissingParams :: !(Maybe [MissingParameter]) -- ^ "missingParams" - Request&#39;s missing parameters.
  , badRequestErrorInvalidParams :: !(Maybe [InvalidParameter]) -- ^ "invalidParams" - Request&#39;s invalid parameters.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BadRequestError
instance A.FromJSON BadRequestError where
  parseJSON = A.withObject "BadRequestError" $ \o ->
    BadRequestError
      <$> (o .:? "status")
      <*> (o .:? "type")
      <*> (o .:? "title")
      <*> (o .:? "missingParams")
      <*> (o .:? "invalidParams")

-- | ToJSON BadRequestError
instance A.ToJSON BadRequestError where
  toJSON BadRequestError {..} =
   _omitNulls
      [ "status" .= badRequestErrorStatus
      , "type" .= badRequestErrorType
      , "title" .= badRequestErrorTitle
      , "missingParams" .= badRequestErrorMissingParams
      , "invalidParams" .= badRequestErrorInvalidParams
      ]


-- | Construct a value of type 'BadRequestError' (by applying it's required fields, if any)
mkBadRequestError
  :: BadRequestError
mkBadRequestError =
  BadRequestError
  { badRequestErrorStatus = Nothing
  , badRequestErrorType = Nothing
  , badRequestErrorTitle = Nothing
  , badRequestErrorMissingParams = Nothing
  , badRequestErrorInvalidParams = Nothing
  }

-- ** BranchList
-- | BranchList
data BranchList = BranchList
  { branchListTotalNumberOfItems :: !(Maybe Int) -- ^ "_totalNumberOfItems"
  , branchListEmbedded :: !(Maybe BranchListEmbedded) -- ^ "_embedded"
  , branchListLinks :: !(Maybe ProgramListLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BranchList
instance A.FromJSON BranchList where
  parseJSON = A.withObject "BranchList" $ \o ->
    BranchList
      <$> (o .:? "_totalNumberOfItems")
      <*> (o .:? "_embedded")
      <*> (o .:? "_links")

-- | ToJSON BranchList
instance A.ToJSON BranchList where
  toJSON BranchList {..} =
   _omitNulls
      [ "_totalNumberOfItems" .= branchListTotalNumberOfItems
      , "_embedded" .= branchListEmbedded
      , "_links" .= branchListLinks
      ]


-- | Construct a value of type 'BranchList' (by applying it's required fields, if any)
mkBranchList
  :: BranchList
mkBranchList =
  BranchList
  { branchListTotalNumberOfItems = Nothing
  , branchListEmbedded = Nothing
  , branchListLinks = Nothing
  }

-- ** BranchListEmbedded
-- | BranchListEmbedded
data BranchListEmbedded = BranchListEmbedded
  { branchListEmbeddedBranches :: !(Maybe [RepositoryBranch]) -- ^ "branches"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BranchListEmbedded
instance A.FromJSON BranchListEmbedded where
  parseJSON = A.withObject "BranchListEmbedded" $ \o ->
    BranchListEmbedded
      <$> (o .:? "branches")

-- | ToJSON BranchListEmbedded
instance A.ToJSON BranchListEmbedded where
  toJSON BranchListEmbedded {..} =
   _omitNulls
      [ "branches" .= branchListEmbeddedBranches
      ]


-- | Construct a value of type 'BranchListEmbedded' (by applying it's required fields, if any)
mkBranchListEmbedded
  :: BranchListEmbedded
mkBranchListEmbedded =
  BranchListEmbedded
  { branchListEmbeddedBranches = Nothing
  }

-- ** EmbeddedProgram
-- | EmbeddedProgram
-- Describes an __Embedded Program__
data EmbeddedProgram = EmbeddedProgram
  { embeddedProgramId :: !(Maybe Text) -- ^ /ReadOnly/ "id" - Identifier of the program. Unique within the space.
  , embeddedProgramName :: !(Maybe Text) -- ^ /ReadOnly/ "name" - Name of the program
  , embeddedProgramEnabled :: !(Maybe Bool) -- ^ /ReadOnly/ "enabled" - Whether this Program has been enabled for Cloud Manager usage
  , embeddedProgramTenantId :: !(Maybe Text) -- ^ /ReadOnly/ "tenantId" - Tenant Id
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EmbeddedProgram
instance A.FromJSON EmbeddedProgram where
  parseJSON = A.withObject "EmbeddedProgram" $ \o ->
    EmbeddedProgram
      <$> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "enabled")
      <*> (o .:? "tenantId")

-- | ToJSON EmbeddedProgram
instance A.ToJSON EmbeddedProgram where
  toJSON EmbeddedProgram {..} =
   _omitNulls
      [ "id" .= embeddedProgramId
      , "name" .= embeddedProgramName
      , "enabled" .= embeddedProgramEnabled
      , "tenantId" .= embeddedProgramTenantId
      ]


-- | Construct a value of type 'EmbeddedProgram' (by applying it's required fields, if any)
mkEmbeddedProgram
  :: EmbeddedProgram
mkEmbeddedProgram =
  EmbeddedProgram
  { embeddedProgramId = Nothing
  , embeddedProgramName = Nothing
  , embeddedProgramEnabled = Nothing
  , embeddedProgramTenantId = Nothing
  }

-- ** Environment
-- | Environment
-- An Environment that 
data Environment = Environment
  { environmentId :: !(Maybe Text) -- ^ "id" - id
  , environmentProgramId :: !(Maybe Text) -- ^ "programId" - Identifier of the program. Unique within the space.
  , environmentName :: !(Maybe Text) -- ^ "name" - Name of the environment
  , environmentDescription :: !(Maybe Text) -- ^ "description" - Description of the environment
  , environmentType :: !(Maybe E'Type2) -- ^ "type" - Type of the environment
  , environmentLinks :: !(Maybe EnvironmentLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Environment
instance A.FromJSON Environment where
  parseJSON = A.withObject "Environment" $ \o ->
    Environment
      <$> (o .:? "id")
      <*> (o .:? "programId")
      <*> (o .:? "name")
      <*> (o .:? "description")
      <*> (o .:? "type")
      <*> (o .:? "_links")

-- | ToJSON Environment
instance A.ToJSON Environment where
  toJSON Environment {..} =
   _omitNulls
      [ "id" .= environmentId
      , "programId" .= environmentProgramId
      , "name" .= environmentName
      , "description" .= environmentDescription
      , "type" .= environmentType
      , "_links" .= environmentLinks
      ]


-- | Construct a value of type 'Environment' (by applying it's required fields, if any)
mkEnvironment
  :: Environment
mkEnvironment =
  Environment
  { environmentId = Nothing
  , environmentProgramId = Nothing
  , environmentName = Nothing
  , environmentDescription = Nothing
  , environmentType = Nothing
  , environmentLinks = Nothing
  }

-- ** EnvironmentLinks
-- | EnvironmentLinks
data EnvironmentLinks = EnvironmentLinks
  { environmentLinksHttpNsAdobeComAdobecloudRelProgram :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/program"
  , environmentLinksHttpNsAdobeComAdobecloudRelPipeline :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/pipeline"
  , environmentLinksHttpNsAdobeComAdobecloudRelAuthor :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/author"
  , environmentLinksHttpNsAdobeComAdobecloudRelPublish :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/publish"
  , environmentLinksHttpNsAdobeComAdobecloudRelDeveloperConsole :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/developerConsole"
  , environmentLinksHttpNsAdobeComAdobecloudRelLogs :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/logs"
  , environmentLinksHttpNsAdobeComAdobecloudRelVariables :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/variables"
  , environmentLinksSelf :: !(Maybe HalLink) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EnvironmentLinks
instance A.FromJSON EnvironmentLinks where
  parseJSON = A.withObject "EnvironmentLinks" $ \o ->
    EnvironmentLinks
      <$> (o .:? "http://ns.adobe.com/adobecloud/rel/program")
      <*> (o .:? "http://ns.adobe.com/adobecloud/rel/pipeline")
      <*> (o .:? "http://ns.adobe.com/adobecloud/rel/author")
      <*> (o .:? "http://ns.adobe.com/adobecloud/rel/publish")
      <*> (o .:? "http://ns.adobe.com/adobecloud/rel/developerConsole")
      <*> (o .:? "http://ns.adobe.com/adobecloud/rel/logs")
      <*> (o .:? "http://ns.adobe.com/adobecloud/rel/variables")
      <*> (o .:? "self")

-- | ToJSON EnvironmentLinks
instance A.ToJSON EnvironmentLinks where
  toJSON EnvironmentLinks {..} =
   _omitNulls
      [ "http://ns.adobe.com/adobecloud/rel/program" .= environmentLinksHttpNsAdobeComAdobecloudRelProgram
      , "http://ns.adobe.com/adobecloud/rel/pipeline" .= environmentLinksHttpNsAdobeComAdobecloudRelPipeline
      , "http://ns.adobe.com/adobecloud/rel/author" .= environmentLinksHttpNsAdobeComAdobecloudRelAuthor
      , "http://ns.adobe.com/adobecloud/rel/publish" .= environmentLinksHttpNsAdobeComAdobecloudRelPublish
      , "http://ns.adobe.com/adobecloud/rel/developerConsole" .= environmentLinksHttpNsAdobeComAdobecloudRelDeveloperConsole
      , "http://ns.adobe.com/adobecloud/rel/logs" .= environmentLinksHttpNsAdobeComAdobecloudRelLogs
      , "http://ns.adobe.com/adobecloud/rel/variables" .= environmentLinksHttpNsAdobeComAdobecloudRelVariables
      , "self" .= environmentLinksSelf
      ]


-- | Construct a value of type 'EnvironmentLinks' (by applying it's required fields, if any)
mkEnvironmentLinks
  :: EnvironmentLinks
mkEnvironmentLinks =
  EnvironmentLinks
  { environmentLinksHttpNsAdobeComAdobecloudRelProgram = Nothing
  , environmentLinksHttpNsAdobeComAdobecloudRelPipeline = Nothing
  , environmentLinksHttpNsAdobeComAdobecloudRelAuthor = Nothing
  , environmentLinksHttpNsAdobeComAdobecloudRelPublish = Nothing
  , environmentLinksHttpNsAdobeComAdobecloudRelDeveloperConsole = Nothing
  , environmentLinksHttpNsAdobeComAdobecloudRelLogs = Nothing
  , environmentLinksHttpNsAdobeComAdobecloudRelVariables = Nothing
  , environmentLinksSelf = Nothing
  }

-- ** EnvironmentList
-- | EnvironmentList
data EnvironmentList = EnvironmentList
  { environmentListTotalNumberOfItems :: !(Maybe Int) -- ^ "_totalNumberOfItems"
  , environmentListEmbedded :: !(Maybe EnvironmentListEmbedded) -- ^ "_embedded"
  , environmentListLinks :: !(Maybe ProgramListLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EnvironmentList
instance A.FromJSON EnvironmentList where
  parseJSON = A.withObject "EnvironmentList" $ \o ->
    EnvironmentList
      <$> (o .:? "_totalNumberOfItems")
      <*> (o .:? "_embedded")
      <*> (o .:? "_links")

-- | ToJSON EnvironmentList
instance A.ToJSON EnvironmentList where
  toJSON EnvironmentList {..} =
   _omitNulls
      [ "_totalNumberOfItems" .= environmentListTotalNumberOfItems
      , "_embedded" .= environmentListEmbedded
      , "_links" .= environmentListLinks
      ]


-- | Construct a value of type 'EnvironmentList' (by applying it's required fields, if any)
mkEnvironmentList
  :: EnvironmentList
mkEnvironmentList =
  EnvironmentList
  { environmentListTotalNumberOfItems = Nothing
  , environmentListEmbedded = Nothing
  , environmentListLinks = Nothing
  }

-- ** EnvironmentListEmbedded
-- | EnvironmentListEmbedded
data EnvironmentListEmbedded = EnvironmentListEmbedded
  { environmentListEmbeddedEnvironments :: !(Maybe [Environment]) -- ^ "environments"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EnvironmentListEmbedded
instance A.FromJSON EnvironmentListEmbedded where
  parseJSON = A.withObject "EnvironmentListEmbedded" $ \o ->
    EnvironmentListEmbedded
      <$> (o .:? "environments")

-- | ToJSON EnvironmentListEmbedded
instance A.ToJSON EnvironmentListEmbedded where
  toJSON EnvironmentListEmbedded {..} =
   _omitNulls
      [ "environments" .= environmentListEmbeddedEnvironments
      ]


-- | Construct a value of type 'EnvironmentListEmbedded' (by applying it's required fields, if any)
mkEnvironmentListEmbedded
  :: EnvironmentListEmbedded
mkEnvironmentListEmbedded =
  EnvironmentListEmbedded
  { environmentListEmbeddedEnvironments = Nothing
  }

-- ** EnvironmentLog
-- | EnvironmentLog
-- Log from Environment
data EnvironmentLog = EnvironmentLog
  { environmentLogService :: !(Maybe Text) -- ^ "service" - Name of the service
  , environmentLogName :: !(Maybe Text) -- ^ "name" - Name of the Log
  , environmentLogDate :: !(Maybe Text) -- ^ "date" - date of the Log
  , environmentLogProgramId :: !(Maybe Integer) -- ^ "programId"
  , environmentLogEnvironmentId :: !(Maybe Integer) -- ^ "environmentId"
  , environmentLogLinks :: !(Maybe EnvironmentLogLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EnvironmentLog
instance A.FromJSON EnvironmentLog where
  parseJSON = A.withObject "EnvironmentLog" $ \o ->
    EnvironmentLog
      <$> (o .:? "service")
      <*> (o .:? "name")
      <*> (o .:? "date")
      <*> (o .:? "programId")
      <*> (o .:? "environmentId")
      <*> (o .:? "_links")

-- | ToJSON EnvironmentLog
instance A.ToJSON EnvironmentLog where
  toJSON EnvironmentLog {..} =
   _omitNulls
      [ "service" .= environmentLogService
      , "name" .= environmentLogName
      , "date" .= environmentLogDate
      , "programId" .= environmentLogProgramId
      , "environmentId" .= environmentLogEnvironmentId
      , "_links" .= environmentLogLinks
      ]


-- | Construct a value of type 'EnvironmentLog' (by applying it's required fields, if any)
mkEnvironmentLog
  :: EnvironmentLog
mkEnvironmentLog =
  EnvironmentLog
  { environmentLogService = Nothing
  , environmentLogName = Nothing
  , environmentLogDate = Nothing
  , environmentLogProgramId = Nothing
  , environmentLogEnvironmentId = Nothing
  , environmentLogLinks = Nothing
  }

-- ** EnvironmentLogLinks
-- | EnvironmentLogLinks
data EnvironmentLogLinks = EnvironmentLogLinks
  { environmentLogLinksHttpNsAdobeComAdobecloudRelLogsDownload :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/logs/download"
  , environmentLogLinksHttpNsAdobeComAdobecloudRelLogsTail :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/logs/tail"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EnvironmentLogLinks
instance A.FromJSON EnvironmentLogLinks where
  parseJSON = A.withObject "EnvironmentLogLinks" $ \o ->
    EnvironmentLogLinks
      <$> (o .:? "http://ns.adobe.com/adobecloud/rel/logs/download")
      <*> (o .:? "http://ns.adobe.com/adobecloud/rel/logs/tail")

-- | ToJSON EnvironmentLogLinks
instance A.ToJSON EnvironmentLogLinks where
  toJSON EnvironmentLogLinks {..} =
   _omitNulls
      [ "http://ns.adobe.com/adobecloud/rel/logs/download" .= environmentLogLinksHttpNsAdobeComAdobecloudRelLogsDownload
      , "http://ns.adobe.com/adobecloud/rel/logs/tail" .= environmentLogLinksHttpNsAdobeComAdobecloudRelLogsTail
      ]


-- | Construct a value of type 'EnvironmentLogLinks' (by applying it's required fields, if any)
mkEnvironmentLogLinks
  :: EnvironmentLogLinks
mkEnvironmentLogLinks =
  EnvironmentLogLinks
  { environmentLogLinksHttpNsAdobeComAdobecloudRelLogsDownload = Nothing
  , environmentLogLinksHttpNsAdobeComAdobecloudRelLogsTail = Nothing
  }

-- ** EnvironmentLogs
-- | EnvironmentLogs
-- Logs of an Environment
data EnvironmentLogs = EnvironmentLogs
  { environmentLogsService :: !(Maybe [Text]) -- ^ "service" - Name of the service
  , environmentLogsName :: !(Maybe [Text]) -- ^ "name" - Name of the Log
  , environmentLogsDays :: !(Maybe Int) -- ^ "days" - Number of days
  , environmentLogsLinks :: !(Maybe EnvironmentLogsLinks) -- ^ "_links"
  , environmentLogsEmbedded :: !(Maybe EnvironmentLogsEmbedded) -- ^ "_embedded"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EnvironmentLogs
instance A.FromJSON EnvironmentLogs where
  parseJSON = A.withObject "EnvironmentLogs" $ \o ->
    EnvironmentLogs
      <$> (o .:? "service")
      <*> (o .:? "name")
      <*> (o .:? "days")
      <*> (o .:? "_links")
      <*> (o .:? "_embedded")

-- | ToJSON EnvironmentLogs
instance A.ToJSON EnvironmentLogs where
  toJSON EnvironmentLogs {..} =
   _omitNulls
      [ "service" .= environmentLogsService
      , "name" .= environmentLogsName
      , "days" .= environmentLogsDays
      , "_links" .= environmentLogsLinks
      , "_embedded" .= environmentLogsEmbedded
      ]


-- | Construct a value of type 'EnvironmentLogs' (by applying it's required fields, if any)
mkEnvironmentLogs
  :: EnvironmentLogs
mkEnvironmentLogs =
  EnvironmentLogs
  { environmentLogsService = Nothing
  , environmentLogsName = Nothing
  , environmentLogsDays = Nothing
  , environmentLogsLinks = Nothing
  , environmentLogsEmbedded = Nothing
  }

-- ** EnvironmentLogsEmbedded
-- | EnvironmentLogsEmbedded
data EnvironmentLogsEmbedded = EnvironmentLogsEmbedded
  { environmentLogsEmbeddedDownloads :: !(Maybe [EnvironmentLog]) -- ^ "downloads" - Links to logs
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EnvironmentLogsEmbedded
instance A.FromJSON EnvironmentLogsEmbedded where
  parseJSON = A.withObject "EnvironmentLogsEmbedded" $ \o ->
    EnvironmentLogsEmbedded
      <$> (o .:? "downloads")

-- | ToJSON EnvironmentLogsEmbedded
instance A.ToJSON EnvironmentLogsEmbedded where
  toJSON EnvironmentLogsEmbedded {..} =
   _omitNulls
      [ "downloads" .= environmentLogsEmbeddedDownloads
      ]


-- | Construct a value of type 'EnvironmentLogsEmbedded' (by applying it's required fields, if any)
mkEnvironmentLogsEmbedded
  :: EnvironmentLogsEmbedded
mkEnvironmentLogsEmbedded =
  EnvironmentLogsEmbedded
  { environmentLogsEmbeddedDownloads = Nothing
  }

-- ** EnvironmentLogsLinks
-- | EnvironmentLogsLinks
data EnvironmentLogsLinks = EnvironmentLogsLinks
  { environmentLogsLinksHttpNsAdobeComAdobecloudRelProgram :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/program"
  , environmentLogsLinksSelf :: !(Maybe HalLink) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EnvironmentLogsLinks
instance A.FromJSON EnvironmentLogsLinks where
  parseJSON = A.withObject "EnvironmentLogsLinks" $ \o ->
    EnvironmentLogsLinks
      <$> (o .:? "http://ns.adobe.com/adobecloud/rel/program")
      <*> (o .:? "self")

-- | ToJSON EnvironmentLogsLinks
instance A.ToJSON EnvironmentLogsLinks where
  toJSON EnvironmentLogsLinks {..} =
   _omitNulls
      [ "http://ns.adobe.com/adobecloud/rel/program" .= environmentLogsLinksHttpNsAdobeComAdobecloudRelProgram
      , "self" .= environmentLogsLinksSelf
      ]


-- | Construct a value of type 'EnvironmentLogsLinks' (by applying it's required fields, if any)
mkEnvironmentLogsLinks
  :: EnvironmentLogsLinks
mkEnvironmentLogsLinks =
  EnvironmentLogsLinks
  { environmentLogsLinksHttpNsAdobeComAdobecloudRelProgram = Nothing
  , environmentLogsLinksSelf = Nothing
  }

-- ** HalLink
-- | HalLink
data HalLink = HalLink
  { halLinkHref :: !(Maybe Text) -- ^ "href"
  , halLinkTemplated :: !(Maybe Bool) -- ^ "templated"
  , halLinkType :: !(Maybe Text) -- ^ "type"
  , halLinkDeprecation :: !(Maybe Text) -- ^ "deprecation"
  , halLinkProfile :: !(Maybe Text) -- ^ "profile"
  , halLinkTitle :: !(Maybe Text) -- ^ "title"
  , halLinkHreflang :: !(Maybe Text) -- ^ "hreflang"
  , halLinkName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HalLink
instance A.FromJSON HalLink where
  parseJSON = A.withObject "HalLink" $ \o ->
    HalLink
      <$> (o .:? "href")
      <*> (o .:? "templated")
      <*> (o .:? "type")
      <*> (o .:? "deprecation")
      <*> (o .:? "profile")
      <*> (o .:? "title")
      <*> (o .:? "hreflang")
      <*> (o .:? "name")

-- | ToJSON HalLink
instance A.ToJSON HalLink where
  toJSON HalLink {..} =
   _omitNulls
      [ "href" .= halLinkHref
      , "templated" .= halLinkTemplated
      , "type" .= halLinkType
      , "deprecation" .= halLinkDeprecation
      , "profile" .= halLinkProfile
      , "title" .= halLinkTitle
      , "hreflang" .= halLinkHreflang
      , "name" .= halLinkName
      ]


-- | Construct a value of type 'HalLink' (by applying it's required fields, if any)
mkHalLink
  :: HalLink
mkHalLink =
  HalLink
  { halLinkHref = Nothing
  , halLinkTemplated = Nothing
  , halLinkType = Nothing
  , halLinkDeprecation = Nothing
  , halLinkProfile = Nothing
  , halLinkTitle = Nothing
  , halLinkHreflang = Nothing
  , halLinkName = Nothing
  }

-- ** InvalidParameter
-- | InvalidParameter
data InvalidParameter = InvalidParameter
  { invalidParameterName :: !(Maybe Text) -- ^ "name" - Name of the invalid parameter.
  , invalidParameterReason :: !(Maybe Text) -- ^ "reason" - Reason of why the parameter&#39;s value is not accepted.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InvalidParameter
instance A.FromJSON InvalidParameter where
  parseJSON = A.withObject "InvalidParameter" $ \o ->
    InvalidParameter
      <$> (o .:? "name")
      <*> (o .:? "reason")

-- | ToJSON InvalidParameter
instance A.ToJSON InvalidParameter where
  toJSON InvalidParameter {..} =
   _omitNulls
      [ "name" .= invalidParameterName
      , "reason" .= invalidParameterReason
      ]


-- | Construct a value of type 'InvalidParameter' (by applying it's required fields, if any)
mkInvalidParameter
  :: InvalidParameter
mkInvalidParameter =
  InvalidParameter
  { invalidParameterName = Nothing
  , invalidParameterReason = Nothing
  }

-- ** Metric
-- | Metric
-- Describes a __Metric__
data Metric = Metric
  { metricId :: !(Maybe Text) -- ^ "id" - KPI result identifier
  , metricSeverity :: !(Maybe E'Severity) -- ^ "severity" - Severity of the metric
  , metricPassed :: !(Maybe Bool) -- ^ "passed" - Whether metric is considered passed
  , metricOverride :: !(Maybe Bool) -- ^ "override" - Whether user override the failed metric
  , metricActualValue :: !(Maybe Text) -- ^ "actualValue" - Expected value for the metric
  , metricExpectedValue :: !(Maybe Text) -- ^ "expectedValue" - Expected value for the metric
  , metricComparator :: !(Maybe E'Comparator) -- ^ "comparator" - Comparator used for the metric
  , metricKpi :: !(Maybe Text) -- ^ "kpi" - KPI identifier
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Metric
instance A.FromJSON Metric where
  parseJSON = A.withObject "Metric" $ \o ->
    Metric
      <$> (o .:? "id")
      <*> (o .:? "severity")
      <*> (o .:? "passed")
      <*> (o .:? "override")
      <*> (o .:? "actualValue")
      <*> (o .:? "expectedValue")
      <*> (o .:? "comparator")
      <*> (o .:? "kpi")

-- | ToJSON Metric
instance A.ToJSON Metric where
  toJSON Metric {..} =
   _omitNulls
      [ "id" .= metricId
      , "severity" .= metricSeverity
      , "passed" .= metricPassed
      , "override" .= metricOverride
      , "actualValue" .= metricActualValue
      , "expectedValue" .= metricExpectedValue
      , "comparator" .= metricComparator
      , "kpi" .= metricKpi
      ]


-- | Construct a value of type 'Metric' (by applying it's required fields, if any)
mkMetric
  :: Metric
mkMetric =
  Metric
  { metricId = Nothing
  , metricSeverity = Nothing
  , metricPassed = Nothing
  , metricOverride = Nothing
  , metricActualValue = Nothing
  , metricExpectedValue = Nothing
  , metricComparator = Nothing
  , metricKpi = Nothing
  }

-- ** MissingParameter
-- | MissingParameter
data MissingParameter = MissingParameter
  { missingParameterName :: !(Maybe Text) -- ^ "name" - Name of the missing parameter.
  , missingParameterType :: !(Maybe Text) -- ^ "type" - Type of the missing parameter.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MissingParameter
instance A.FromJSON MissingParameter where
  parseJSON = A.withObject "MissingParameter" $ \o ->
    MissingParameter
      <$> (o .:? "name")
      <*> (o .:? "type")

-- | ToJSON MissingParameter
instance A.ToJSON MissingParameter where
  toJSON MissingParameter {..} =
   _omitNulls
      [ "name" .= missingParameterName
      , "type" .= missingParameterType
      ]


-- | Construct a value of type 'MissingParameter' (by applying it's required fields, if any)
mkMissingParameter
  :: MissingParameter
mkMissingParameter =
  MissingParameter
  { missingParameterName = Nothing
  , missingParameterType = Nothing
  }

-- ** Pipeline
-- | Pipeline
-- Describes a __CI/CD Pipeline__
data Pipeline = Pipeline
  { pipelineId :: !(Maybe Text) -- ^ "id" - Identifier of the pipeline. Unique within the program.
  , pipelineProgramId :: !(Maybe Text) -- ^ "programId" - Identifier of the program. Unique within the space.
  , pipelineName :: !(Text) -- ^ /Required/ "name" - Name of the pipeline
  , pipelineTrigger :: !(Maybe E'Trigger) -- ^ "trigger" - How should the execution be triggered. ON_COMMIT: each time a PR is available and the Pipeline is idle then a execution is triggered. MANUAL: triggerd through UI or API. SCHEDULE: recurring schedule (not yet implemented}
  , pipelineStatus :: !(Maybe E'Status) -- ^ "status" - Pipeline status
  , pipelineCreatedAt :: !(Maybe DateTime) -- ^ /ReadOnly/ "createdAt" - Create date
  , pipelineUpdatedAt :: !(Maybe DateTime) -- ^ /ReadOnly/ "updatedAt" - Update date
  , pipelineLastStartedAt :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastStartedAt" - Last pipeline execution start
  , pipelineLastFinishedAt :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastFinishedAt" - Last pipeline execution end
  , pipelinePhases :: !([PipelinePhase]) -- ^ /Required/ "phases" - Pipeline phases in execution order
  , pipelineLinks :: !(Maybe PipelineLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Pipeline
instance A.FromJSON Pipeline where
  parseJSON = A.withObject "Pipeline" $ \o ->
    Pipeline
      <$> (o .:? "id")
      <*> (o .:? "programId")
      <*> (o .:  "name")
      <*> (o .:? "trigger")
      <*> (o .:? "status")
      <*> (o .:? "createdAt")
      <*> (o .:? "updatedAt")
      <*> (o .:? "lastStartedAt")
      <*> (o .:? "lastFinishedAt")
      <*> (o .:  "phases")
      <*> (o .:? "_links")

-- | ToJSON Pipeline
instance A.ToJSON Pipeline where
  toJSON Pipeline {..} =
   _omitNulls
      [ "id" .= pipelineId
      , "programId" .= pipelineProgramId
      , "name" .= pipelineName
      , "trigger" .= pipelineTrigger
      , "status" .= pipelineStatus
      , "createdAt" .= pipelineCreatedAt
      , "updatedAt" .= pipelineUpdatedAt
      , "lastStartedAt" .= pipelineLastStartedAt
      , "lastFinishedAt" .= pipelineLastFinishedAt
      , "phases" .= pipelinePhases
      , "_links" .= pipelineLinks
      ]


-- | Construct a value of type 'Pipeline' (by applying it's required fields, if any)
mkPipeline
  :: Text -- ^ 'pipelineName': Name of the pipeline
  -> [PipelinePhase] -- ^ 'pipelinePhases': Pipeline phases in execution order
  -> Pipeline
mkPipeline pipelineName pipelinePhases =
  Pipeline
  { pipelineId = Nothing
  , pipelineProgramId = Nothing
  , pipelineName
  , pipelineTrigger = Nothing
  , pipelineStatus = Nothing
  , pipelineCreatedAt = Nothing
  , pipelineUpdatedAt = Nothing
  , pipelineLastStartedAt = Nothing
  , pipelineLastFinishedAt = Nothing
  , pipelinePhases
  , pipelineLinks = Nothing
  }

-- ** PipelineExecution
-- | PipelineExecution
-- Wraps a pipeline execution
data PipelineExecution = PipelineExecution
  { pipelineExecutionId :: !(Maybe Text) -- ^ "id" - Pipeline execution identifier
  , pipelineExecutionProgramId :: !(Maybe Text) -- ^ /ReadOnly/ "programId" - Identifier of the program. Unique within the space.
  , pipelineExecutionPipelineId :: !(Maybe Text) -- ^ /ReadOnly/ "pipelineId" - Identifier of the pipeline. Unique within the space.
  , pipelineExecutionArtifactsVersion :: !(Maybe Text) -- ^ "artifactsVersion" - Version of the artifacts generated during this execution
  , pipelineExecutionUser :: !(Maybe Text) -- ^ "user" - AdobeID who started the pipeline. Empty for auto triggered builds
  , pipelineExecutionStatus :: !(Maybe E'Status2) -- ^ "status" - Status of the execution
  , pipelineExecutionTrigger :: !(Maybe E'Trigger2) -- ^ "trigger" - How the execution was triggered.
  , pipelineExecutionCreatedAt :: !(Maybe DateTime) -- ^ "createdAt" - Start time
  , pipelineExecutionUpdatedAt :: !(Maybe DateTime) -- ^ "updatedAt" - Date of last status change
  , pipelineExecutionFinishedAt :: !(Maybe DateTime) -- ^ "finishedAt" - Date the execution reached a final state
  , pipelineExecutionEmbedded :: !(Maybe PipelineExecutionEmbedded) -- ^ "_embedded"
  , pipelineExecutionLinks :: !(Maybe PipelineExecutionLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelineExecution
instance A.FromJSON PipelineExecution where
  parseJSON = A.withObject "PipelineExecution" $ \o ->
    PipelineExecution
      <$> (o .:? "id")
      <*> (o .:? "programId")
      <*> (o .:? "pipelineId")
      <*> (o .:? "artifactsVersion")
      <*> (o .:? "user")
      <*> (o .:? "status")
      <*> (o .:? "trigger")
      <*> (o .:? "createdAt")
      <*> (o .:? "updatedAt")
      <*> (o .:? "finishedAt")
      <*> (o .:? "_embedded")
      <*> (o .:? "_links")

-- | ToJSON PipelineExecution
instance A.ToJSON PipelineExecution where
  toJSON PipelineExecution {..} =
   _omitNulls
      [ "id" .= pipelineExecutionId
      , "programId" .= pipelineExecutionProgramId
      , "pipelineId" .= pipelineExecutionPipelineId
      , "artifactsVersion" .= pipelineExecutionArtifactsVersion
      , "user" .= pipelineExecutionUser
      , "status" .= pipelineExecutionStatus
      , "trigger" .= pipelineExecutionTrigger
      , "createdAt" .= pipelineExecutionCreatedAt
      , "updatedAt" .= pipelineExecutionUpdatedAt
      , "finishedAt" .= pipelineExecutionFinishedAt
      , "_embedded" .= pipelineExecutionEmbedded
      , "_links" .= pipelineExecutionLinks
      ]


-- | Construct a value of type 'PipelineExecution' (by applying it's required fields, if any)
mkPipelineExecution
  :: PipelineExecution
mkPipelineExecution =
  PipelineExecution
  { pipelineExecutionId = Nothing
  , pipelineExecutionProgramId = Nothing
  , pipelineExecutionPipelineId = Nothing
  , pipelineExecutionArtifactsVersion = Nothing
  , pipelineExecutionUser = Nothing
  , pipelineExecutionStatus = Nothing
  , pipelineExecutionTrigger = Nothing
  , pipelineExecutionCreatedAt = Nothing
  , pipelineExecutionUpdatedAt = Nothing
  , pipelineExecutionFinishedAt = Nothing
  , pipelineExecutionEmbedded = Nothing
  , pipelineExecutionLinks = Nothing
  }

-- ** PipelineExecutionEmbedded
-- | PipelineExecutionEmbedded
data PipelineExecutionEmbedded = PipelineExecutionEmbedded
  { pipelineExecutionEmbeddedStepStates :: !(Maybe [PipelineExecutionStepState]) -- ^ "stepStates"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelineExecutionEmbedded
instance A.FromJSON PipelineExecutionEmbedded where
  parseJSON = A.withObject "PipelineExecutionEmbedded" $ \o ->
    PipelineExecutionEmbedded
      <$> (o .:? "stepStates")

-- | ToJSON PipelineExecutionEmbedded
instance A.ToJSON PipelineExecutionEmbedded where
  toJSON PipelineExecutionEmbedded {..} =
   _omitNulls
      [ "stepStates" .= pipelineExecutionEmbeddedStepStates
      ]


-- | Construct a value of type 'PipelineExecutionEmbedded' (by applying it's required fields, if any)
mkPipelineExecutionEmbedded
  :: PipelineExecutionEmbedded
mkPipelineExecutionEmbedded =
  PipelineExecutionEmbedded
  { pipelineExecutionEmbeddedStepStates = Nothing
  }

-- ** PipelineExecutionLinks
-- | PipelineExecutionLinks
data PipelineExecutionLinks = PipelineExecutionLinks
  { pipelineExecutionLinksHttpNsAdobeComAdobecloudRelProgram :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/program"
  , pipelineExecutionLinksHttpNsAdobeComAdobecloudRelPipeline :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/pipeline"
  , pipelineExecutionLinksSelf :: !(Maybe HalLink) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelineExecutionLinks
instance A.FromJSON PipelineExecutionLinks where
  parseJSON = A.withObject "PipelineExecutionLinks" $ \o ->
    PipelineExecutionLinks
      <$> (o .:? "http://ns.adobe.com/adobecloud/rel/program")
      <*> (o .:? "http://ns.adobe.com/adobecloud/rel/pipeline")
      <*> (o .:? "self")

-- | ToJSON PipelineExecutionLinks
instance A.ToJSON PipelineExecutionLinks where
  toJSON PipelineExecutionLinks {..} =
   _omitNulls
      [ "http://ns.adobe.com/adobecloud/rel/program" .= pipelineExecutionLinksHttpNsAdobeComAdobecloudRelProgram
      , "http://ns.adobe.com/adobecloud/rel/pipeline" .= pipelineExecutionLinksHttpNsAdobeComAdobecloudRelPipeline
      , "self" .= pipelineExecutionLinksSelf
      ]


-- | Construct a value of type 'PipelineExecutionLinks' (by applying it's required fields, if any)
mkPipelineExecutionLinks
  :: PipelineExecutionLinks
mkPipelineExecutionLinks =
  PipelineExecutionLinks
  { pipelineExecutionLinksHttpNsAdobeComAdobecloudRelProgram = Nothing
  , pipelineExecutionLinksHttpNsAdobeComAdobecloudRelPipeline = Nothing
  , pipelineExecutionLinksSelf = Nothing
  }

-- ** PipelineExecutionListRepresentation
-- | PipelineExecutionListRepresentation
-- List of pipeline executions
data PipelineExecutionListRepresentation = PipelineExecutionListRepresentation
  { pipelineExecutionListRepresentationTotalNumberOfItems :: !(Maybe Int) -- ^ "_totalNumberOfItems"
  , pipelineExecutionListRepresentationPage :: !(Maybe RequestedPageDetails) -- ^ "_page"
  , pipelineExecutionListRepresentationEmbedded :: !(Maybe PipelineExecutionListRepresentationEmbedded) -- ^ "_embedded"
  , pipelineExecutionListRepresentationLinks :: !(Maybe PipelineExecutionListRepresentationLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelineExecutionListRepresentation
instance A.FromJSON PipelineExecutionListRepresentation where
  parseJSON = A.withObject "PipelineExecutionListRepresentation" $ \o ->
    PipelineExecutionListRepresentation
      <$> (o .:? "_totalNumberOfItems")
      <*> (o .:? "_page")
      <*> (o .:? "_embedded")
      <*> (o .:? "_links")

-- | ToJSON PipelineExecutionListRepresentation
instance A.ToJSON PipelineExecutionListRepresentation where
  toJSON PipelineExecutionListRepresentation {..} =
   _omitNulls
      [ "_totalNumberOfItems" .= pipelineExecutionListRepresentationTotalNumberOfItems
      , "_page" .= pipelineExecutionListRepresentationPage
      , "_embedded" .= pipelineExecutionListRepresentationEmbedded
      , "_links" .= pipelineExecutionListRepresentationLinks
      ]


-- | Construct a value of type 'PipelineExecutionListRepresentation' (by applying it's required fields, if any)
mkPipelineExecutionListRepresentation
  :: PipelineExecutionListRepresentation
mkPipelineExecutionListRepresentation =
  PipelineExecutionListRepresentation
  { pipelineExecutionListRepresentationTotalNumberOfItems = Nothing
  , pipelineExecutionListRepresentationPage = Nothing
  , pipelineExecutionListRepresentationEmbedded = Nothing
  , pipelineExecutionListRepresentationLinks = Nothing
  }

-- ** PipelineExecutionListRepresentationEmbedded
-- | PipelineExecutionListRepresentationEmbedded
data PipelineExecutionListRepresentationEmbedded = PipelineExecutionListRepresentationEmbedded
  { pipelineExecutionListRepresentationEmbeddedExecutions :: !(Maybe [PipelineExecution]) -- ^ "executions"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelineExecutionListRepresentationEmbedded
instance A.FromJSON PipelineExecutionListRepresentationEmbedded where
  parseJSON = A.withObject "PipelineExecutionListRepresentationEmbedded" $ \o ->
    PipelineExecutionListRepresentationEmbedded
      <$> (o .:? "executions")

-- | ToJSON PipelineExecutionListRepresentationEmbedded
instance A.ToJSON PipelineExecutionListRepresentationEmbedded where
  toJSON PipelineExecutionListRepresentationEmbedded {..} =
   _omitNulls
      [ "executions" .= pipelineExecutionListRepresentationEmbeddedExecutions
      ]


-- | Construct a value of type 'PipelineExecutionListRepresentationEmbedded' (by applying it's required fields, if any)
mkPipelineExecutionListRepresentationEmbedded
  :: PipelineExecutionListRepresentationEmbedded
mkPipelineExecutionListRepresentationEmbedded =
  PipelineExecutionListRepresentationEmbedded
  { pipelineExecutionListRepresentationEmbeddedExecutions = Nothing
  }

-- ** PipelineExecutionListRepresentationLinks
-- | PipelineExecutionListRepresentationLinks
data PipelineExecutionListRepresentationLinks = PipelineExecutionListRepresentationLinks
  { pipelineExecutionListRepresentationLinksNext :: !(Maybe HalLink) -- ^ "next"
  , pipelineExecutionListRepresentationLinksPage :: !(Maybe HalLink) -- ^ "page"
  , pipelineExecutionListRepresentationLinksPrev :: !(Maybe HalLink) -- ^ "prev"
  , pipelineExecutionListRepresentationLinksSelf :: !(Maybe HalLink) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelineExecutionListRepresentationLinks
instance A.FromJSON PipelineExecutionListRepresentationLinks where
  parseJSON = A.withObject "PipelineExecutionListRepresentationLinks" $ \o ->
    PipelineExecutionListRepresentationLinks
      <$> (o .:? "next")
      <*> (o .:? "page")
      <*> (o .:? "prev")
      <*> (o .:? "self")

-- | ToJSON PipelineExecutionListRepresentationLinks
instance A.ToJSON PipelineExecutionListRepresentationLinks where
  toJSON PipelineExecutionListRepresentationLinks {..} =
   _omitNulls
      [ "next" .= pipelineExecutionListRepresentationLinksNext
      , "page" .= pipelineExecutionListRepresentationLinksPage
      , "prev" .= pipelineExecutionListRepresentationLinksPrev
      , "self" .= pipelineExecutionListRepresentationLinksSelf
      ]


-- | Construct a value of type 'PipelineExecutionListRepresentationLinks' (by applying it's required fields, if any)
mkPipelineExecutionListRepresentationLinks
  :: PipelineExecutionListRepresentationLinks
mkPipelineExecutionListRepresentationLinks =
  PipelineExecutionListRepresentationLinks
  { pipelineExecutionListRepresentationLinksNext = Nothing
  , pipelineExecutionListRepresentationLinksPage = Nothing
  , pipelineExecutionListRepresentationLinksPrev = Nothing
  , pipelineExecutionListRepresentationLinksSelf = Nothing
  }

-- ** PipelineExecutionStepState
-- | PipelineExecutionStepState
-- Describes the status of a particular pipeline execution step for display purposes
data PipelineExecutionStepState = PipelineExecutionStepState
  { pipelineExecutionStepStateId :: !(Maybe Text) -- ^ "id"
  , pipelineExecutionStepStateStepId :: !(Maybe Text) -- ^ "stepId"
  , pipelineExecutionStepStatePhaseId :: !(Maybe Text) -- ^ "phaseId"
  , pipelineExecutionStepStateAction :: !(Maybe Text) -- ^ "action" - Name of the action
  , pipelineExecutionStepStateRepository :: !(Maybe Text) -- ^ "repository" - Target repository
  , pipelineExecutionStepStateBranch :: !(Maybe Text) -- ^ "branch" - Target branch
  , pipelineExecutionStepStateEnvironment :: !(Maybe Text) -- ^ "environment" - Target environment
  , pipelineExecutionStepStateEnvironmentType :: !(Maybe Text) -- ^ "environmentType" - Target environment type
  , pipelineExecutionStepStateStartedAt :: !(Maybe DateTime) -- ^ "startedAt" - Start time
  , pipelineExecutionStepStateFinishedAt :: !(Maybe DateTime) -- ^ "finishedAt" - Date the execution reached a final state
  , pipelineExecutionStepStateDetails :: !(Maybe (Map.Map String A.Value)) -- ^ "details" - Information about step result
  , pipelineExecutionStepStateStatus :: !(Maybe E'Status3) -- ^ "status" - Action status
  , pipelineExecutionStepStateLinks :: !(Maybe PipelineExecutionStepStateLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelineExecutionStepState
instance A.FromJSON PipelineExecutionStepState where
  parseJSON = A.withObject "PipelineExecutionStepState" $ \o ->
    PipelineExecutionStepState
      <$> (o .:? "id")
      <*> (o .:? "stepId")
      <*> (o .:? "phaseId")
      <*> (o .:? "action")
      <*> (o .:? "repository")
      <*> (o .:? "branch")
      <*> (o .:? "environment")
      <*> (o .:? "environmentType")
      <*> (o .:? "startedAt")
      <*> (o .:? "finishedAt")
      <*> (o .:? "details")
      <*> (o .:? "status")
      <*> (o .:? "_links")

-- | ToJSON PipelineExecutionStepState
instance A.ToJSON PipelineExecutionStepState where
  toJSON PipelineExecutionStepState {..} =
   _omitNulls
      [ "id" .= pipelineExecutionStepStateId
      , "stepId" .= pipelineExecutionStepStateStepId
      , "phaseId" .= pipelineExecutionStepStatePhaseId
      , "action" .= pipelineExecutionStepStateAction
      , "repository" .= pipelineExecutionStepStateRepository
      , "branch" .= pipelineExecutionStepStateBranch
      , "environment" .= pipelineExecutionStepStateEnvironment
      , "environmentType" .= pipelineExecutionStepStateEnvironmentType
      , "startedAt" .= pipelineExecutionStepStateStartedAt
      , "finishedAt" .= pipelineExecutionStepStateFinishedAt
      , "details" .= pipelineExecutionStepStateDetails
      , "status" .= pipelineExecutionStepStateStatus
      , "_links" .= pipelineExecutionStepStateLinks
      ]


-- | Construct a value of type 'PipelineExecutionStepState' (by applying it's required fields, if any)
mkPipelineExecutionStepState
  :: PipelineExecutionStepState
mkPipelineExecutionStepState =
  PipelineExecutionStepState
  { pipelineExecutionStepStateId = Nothing
  , pipelineExecutionStepStateStepId = Nothing
  , pipelineExecutionStepStatePhaseId = Nothing
  , pipelineExecutionStepStateAction = Nothing
  , pipelineExecutionStepStateRepository = Nothing
  , pipelineExecutionStepStateBranch = Nothing
  , pipelineExecutionStepStateEnvironment = Nothing
  , pipelineExecutionStepStateEnvironmentType = Nothing
  , pipelineExecutionStepStateStartedAt = Nothing
  , pipelineExecutionStepStateFinishedAt = Nothing
  , pipelineExecutionStepStateDetails = Nothing
  , pipelineExecutionStepStateStatus = Nothing
  , pipelineExecutionStepStateLinks = Nothing
  }

-- ** PipelineExecutionStepStateLinks
-- | PipelineExecutionStepStateLinks
data PipelineExecutionStepStateLinks = PipelineExecutionStepStateLinks
  { pipelineExecutionStepStateLinksHttpNsAdobeComAdobecloudRelExecution :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/execution"
  , pipelineExecutionStepStateLinksHttpNsAdobeComAdobecloudRelPipeline :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/pipeline"
  , pipelineExecutionStepStateLinksHttpNsAdobeComAdobecloudRelPipelineLogs :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/pipeline/logs"
  , pipelineExecutionStepStateLinksHttpNsAdobeComAdobecloudRelPipelineMetrics :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/pipeline/metrics"
  , pipelineExecutionStepStateLinksHttpNsAdobeComAdobecloudRelPipelineAdvance :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/pipeline/advance"
  , pipelineExecutionStepStateLinksHttpNsAdobeComAdobecloudRelPipelineCancel :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/pipeline/cancel"
  , pipelineExecutionStepStateLinksHttpNsAdobeComAdobecloudRelProgram :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/program"
  , pipelineExecutionStepStateLinksSelf :: !(Maybe HalLink) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelineExecutionStepStateLinks
instance A.FromJSON PipelineExecutionStepStateLinks where
  parseJSON = A.withObject "PipelineExecutionStepStateLinks" $ \o ->
    PipelineExecutionStepStateLinks
      <$> (o .:? "http://ns.adobe.com/adobecloud/rel/execution")
      <*> (o .:? "http://ns.adobe.com/adobecloud/rel/pipeline")
      <*> (o .:? "http://ns.adobe.com/adobecloud/rel/pipeline/logs")
      <*> (o .:? "http://ns.adobe.com/adobecloud/rel/pipeline/metrics")
      <*> (o .:? "http://ns.adobe.com/adobecloud/rel/pipeline/advance")
      <*> (o .:? "http://ns.adobe.com/adobecloud/rel/pipeline/cancel")
      <*> (o .:? "http://ns.adobe.com/adobecloud/rel/program")
      <*> (o .:? "self")

-- | ToJSON PipelineExecutionStepStateLinks
instance A.ToJSON PipelineExecutionStepStateLinks where
  toJSON PipelineExecutionStepStateLinks {..} =
   _omitNulls
      [ "http://ns.adobe.com/adobecloud/rel/execution" .= pipelineExecutionStepStateLinksHttpNsAdobeComAdobecloudRelExecution
      , "http://ns.adobe.com/adobecloud/rel/pipeline" .= pipelineExecutionStepStateLinksHttpNsAdobeComAdobecloudRelPipeline
      , "http://ns.adobe.com/adobecloud/rel/pipeline/logs" .= pipelineExecutionStepStateLinksHttpNsAdobeComAdobecloudRelPipelineLogs
      , "http://ns.adobe.com/adobecloud/rel/pipeline/metrics" .= pipelineExecutionStepStateLinksHttpNsAdobeComAdobecloudRelPipelineMetrics
      , "http://ns.adobe.com/adobecloud/rel/pipeline/advance" .= pipelineExecutionStepStateLinksHttpNsAdobeComAdobecloudRelPipelineAdvance
      , "http://ns.adobe.com/adobecloud/rel/pipeline/cancel" .= pipelineExecutionStepStateLinksHttpNsAdobeComAdobecloudRelPipelineCancel
      , "http://ns.adobe.com/adobecloud/rel/program" .= pipelineExecutionStepStateLinksHttpNsAdobeComAdobecloudRelProgram
      , "self" .= pipelineExecutionStepStateLinksSelf
      ]


-- | Construct a value of type 'PipelineExecutionStepStateLinks' (by applying it's required fields, if any)
mkPipelineExecutionStepStateLinks
  :: PipelineExecutionStepStateLinks
mkPipelineExecutionStepStateLinks =
  PipelineExecutionStepStateLinks
  { pipelineExecutionStepStateLinksHttpNsAdobeComAdobecloudRelExecution = Nothing
  , pipelineExecutionStepStateLinksHttpNsAdobeComAdobecloudRelPipeline = Nothing
  , pipelineExecutionStepStateLinksHttpNsAdobeComAdobecloudRelPipelineLogs = Nothing
  , pipelineExecutionStepStateLinksHttpNsAdobeComAdobecloudRelPipelineMetrics = Nothing
  , pipelineExecutionStepStateLinksHttpNsAdobeComAdobecloudRelPipelineAdvance = Nothing
  , pipelineExecutionStepStateLinksHttpNsAdobeComAdobecloudRelPipelineCancel = Nothing
  , pipelineExecutionStepStateLinksHttpNsAdobeComAdobecloudRelProgram = Nothing
  , pipelineExecutionStepStateLinksSelf = Nothing
  }

-- ** PipelineLinks
-- | PipelineLinks
data PipelineLinks = PipelineLinks
  { pipelineLinksHttpNsAdobeComAdobecloudRelProgram :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/program"
  , pipelineLinksHttpNsAdobeComAdobecloudRelExecution :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/execution"
  , pipelineLinksHttpNsAdobeComAdobecloudRelExecutions :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/executions"
  , pipelineLinksHttpNsAdobeComAdobecloudRelRollbackLastSuccessfulExecution :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/rollbackLastSuccessfulExecution"
  , pipelineLinksSelf :: !(Maybe HalLink) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelineLinks
instance A.FromJSON PipelineLinks where
  parseJSON = A.withObject "PipelineLinks" $ \o ->
    PipelineLinks
      <$> (o .:? "http://ns.adobe.com/adobecloud/rel/program")
      <*> (o .:? "http://ns.adobe.com/adobecloud/rel/execution")
      <*> (o .:? "http://ns.adobe.com/adobecloud/rel/executions")
      <*> (o .:? "http://ns.adobe.com/adobecloud/rel/rollbackLastSuccessfulExecution")
      <*> (o .:? "self")

-- | ToJSON PipelineLinks
instance A.ToJSON PipelineLinks where
  toJSON PipelineLinks {..} =
   _omitNulls
      [ "http://ns.adobe.com/adobecloud/rel/program" .= pipelineLinksHttpNsAdobeComAdobecloudRelProgram
      , "http://ns.adobe.com/adobecloud/rel/execution" .= pipelineLinksHttpNsAdobeComAdobecloudRelExecution
      , "http://ns.adobe.com/adobecloud/rel/executions" .= pipelineLinksHttpNsAdobeComAdobecloudRelExecutions
      , "http://ns.adobe.com/adobecloud/rel/rollbackLastSuccessfulExecution" .= pipelineLinksHttpNsAdobeComAdobecloudRelRollbackLastSuccessfulExecution
      , "self" .= pipelineLinksSelf
      ]


-- | Construct a value of type 'PipelineLinks' (by applying it's required fields, if any)
mkPipelineLinks
  :: PipelineLinks
mkPipelineLinks =
  PipelineLinks
  { pipelineLinksHttpNsAdobeComAdobecloudRelProgram = Nothing
  , pipelineLinksHttpNsAdobeComAdobecloudRelExecution = Nothing
  , pipelineLinksHttpNsAdobeComAdobecloudRelExecutions = Nothing
  , pipelineLinksHttpNsAdobeComAdobecloudRelRollbackLastSuccessfulExecution = Nothing
  , pipelineLinksSelf = Nothing
  }

-- ** PipelineList
-- | PipelineList
data PipelineList = PipelineList
  { pipelineListTotalNumberOfItems :: !(Maybe Int) -- ^ "_totalNumberOfItems"
  , pipelineListEmbedded :: !(Maybe PipelineListEmbedded) -- ^ "_embedded"
  , pipelineListLinks :: !(Maybe ProgramListLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelineList
instance A.FromJSON PipelineList where
  parseJSON = A.withObject "PipelineList" $ \o ->
    PipelineList
      <$> (o .:? "_totalNumberOfItems")
      <*> (o .:? "_embedded")
      <*> (o .:? "_links")

-- | ToJSON PipelineList
instance A.ToJSON PipelineList where
  toJSON PipelineList {..} =
   _omitNulls
      [ "_totalNumberOfItems" .= pipelineListTotalNumberOfItems
      , "_embedded" .= pipelineListEmbedded
      , "_links" .= pipelineListLinks
      ]


-- | Construct a value of type 'PipelineList' (by applying it's required fields, if any)
mkPipelineList
  :: PipelineList
mkPipelineList =
  PipelineList
  { pipelineListTotalNumberOfItems = Nothing
  , pipelineListEmbedded = Nothing
  , pipelineListLinks = Nothing
  }

-- ** PipelineListEmbedded
-- | PipelineListEmbedded
data PipelineListEmbedded = PipelineListEmbedded
  { pipelineListEmbeddedPipelines :: !(Maybe [Pipeline]) -- ^ "pipelines"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelineListEmbedded
instance A.FromJSON PipelineListEmbedded where
  parseJSON = A.withObject "PipelineListEmbedded" $ \o ->
    PipelineListEmbedded
      <$> (o .:? "pipelines")

-- | ToJSON PipelineListEmbedded
instance A.ToJSON PipelineListEmbedded where
  toJSON PipelineListEmbedded {..} =
   _omitNulls
      [ "pipelines" .= pipelineListEmbeddedPipelines
      ]


-- | Construct a value of type 'PipelineListEmbedded' (by applying it's required fields, if any)
mkPipelineListEmbedded
  :: PipelineListEmbedded
mkPipelineListEmbedded =
  PipelineListEmbedded
  { pipelineListEmbeddedPipelines = Nothing
  }

-- ** PipelinePhase
-- | PipelinePhase
-- Describes a phase of a pipeline
data PipelinePhase = PipelinePhase
  { pipelinePhaseName :: !(Maybe Text) -- ^ "name" - Name of the phase
  , pipelinePhaseType :: !(E'Type) -- ^ /Required/ "type" - Type of the phase
  , pipelinePhaseRepositoryId :: !(Maybe Text) -- ^ "repositoryId" - Identifier of the source repository. The code from this repository will be build at the start of this phase. Mandatory if type&#x3D;BUILD
  , pipelinePhaseBranch :: !(Maybe Text) -- ^ "branch" - Name of the tracked branch or a fully qualified git tag (e.g. refs/tags/v1).  Assumed to be &#x60;master&#x60; if missing.
  , pipelinePhaseEnvironmentId :: !(Maybe Text) -- ^ "environmentId" - Identifier of the target environment. Mandatory if type&#x3D;DEPLOY
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelinePhase
instance A.FromJSON PipelinePhase where
  parseJSON = A.withObject "PipelinePhase" $ \o ->
    PipelinePhase
      <$> (o .:? "name")
      <*> (o .:  "type")
      <*> (o .:? "repositoryId")
      <*> (o .:? "branch")
      <*> (o .:? "environmentId")

-- | ToJSON PipelinePhase
instance A.ToJSON PipelinePhase where
  toJSON PipelinePhase {..} =
   _omitNulls
      [ "name" .= pipelinePhaseName
      , "type" .= pipelinePhaseType
      , "repositoryId" .= pipelinePhaseRepositoryId
      , "branch" .= pipelinePhaseBranch
      , "environmentId" .= pipelinePhaseEnvironmentId
      ]


-- | Construct a value of type 'PipelinePhase' (by applying it's required fields, if any)
mkPipelinePhase
  :: E'Type -- ^ 'pipelinePhaseType': Type of the phase
  -> PipelinePhase
mkPipelinePhase pipelinePhaseType =
  PipelinePhase
  { pipelinePhaseName = Nothing
  , pipelinePhaseType
  , pipelinePhaseRepositoryId = Nothing
  , pipelinePhaseBranch = Nothing
  , pipelinePhaseEnvironmentId = Nothing
  }

-- ** PipelineStepMetrics
-- | PipelineStepMetrics
data PipelineStepMetrics = PipelineStepMetrics
  { pipelineStepMetricsMetrics :: !(Maybe [Metric]) -- ^ /ReadOnly/ "metrics" - metrics
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelineStepMetrics
instance A.FromJSON PipelineStepMetrics where
  parseJSON = A.withObject "PipelineStepMetrics" $ \o ->
    PipelineStepMetrics
      <$> (o .:? "metrics")

-- | ToJSON PipelineStepMetrics
instance A.ToJSON PipelineStepMetrics where
  toJSON PipelineStepMetrics {..} =
   _omitNulls
      [ "metrics" .= pipelineStepMetricsMetrics
      ]


-- | Construct a value of type 'PipelineStepMetrics' (by applying it's required fields, if any)
mkPipelineStepMetrics
  :: PipelineStepMetrics
mkPipelineStepMetrics =
  PipelineStepMetrics
  { pipelineStepMetricsMetrics = Nothing
  }

-- ** Program
-- | Program
-- Describes a __Program__
data Program = Program
  { programId :: !(Maybe Text) -- ^ "id" - Identifier of the program. Unique within the space.
  , programName :: !(Text) -- ^ /Required/ "name" - Name of the program
  , programEnabled :: !(Maybe Bool) -- ^ "enabled" - Whether this Program has been enabled for Cloud Manager usage
  , programTenantId :: !(Maybe Text) -- ^ "tenantId" - Tenant Id
  , programImsOrgId :: !(Maybe Text) -- ^ "imsOrgId" - Organisation Id
  , programLinks :: !(Maybe ProgramLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Program
instance A.FromJSON Program where
  parseJSON = A.withObject "Program" $ \o ->
    Program
      <$> (o .:? "id")
      <*> (o .:  "name")
      <*> (o .:? "enabled")
      <*> (o .:? "tenantId")
      <*> (o .:? "imsOrgId")
      <*> (o .:? "_links")

-- | ToJSON Program
instance A.ToJSON Program where
  toJSON Program {..} =
   _omitNulls
      [ "id" .= programId
      , "name" .= programName
      , "enabled" .= programEnabled
      , "tenantId" .= programTenantId
      , "imsOrgId" .= programImsOrgId
      , "_links" .= programLinks
      ]


-- | Construct a value of type 'Program' (by applying it's required fields, if any)
mkProgram
  :: Text -- ^ 'programName': Name of the program
  -> Program
mkProgram programName =
  Program
  { programId = Nothing
  , programName
  , programEnabled = Nothing
  , programTenantId = Nothing
  , programImsOrgId = Nothing
  , programLinks = Nothing
  }

-- ** ProgramLinks
-- | ProgramLinks
data ProgramLinks = ProgramLinks
  { programLinksHttpNsAdobeComAdobecloudRelPipelines :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/pipelines"
  , programLinksHttpNsAdobeComAdobecloudRelEnvironments :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/environments"
  , programLinksHttpNsAdobeComAdobecloudRelRepositories :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/repositories"
  , programLinksSelf :: !(Maybe HalLink) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProgramLinks
instance A.FromJSON ProgramLinks where
  parseJSON = A.withObject "ProgramLinks" $ \o ->
    ProgramLinks
      <$> (o .:? "http://ns.adobe.com/adobecloud/rel/pipelines")
      <*> (o .:? "http://ns.adobe.com/adobecloud/rel/environments")
      <*> (o .:? "http://ns.adobe.com/adobecloud/rel/repositories")
      <*> (o .:? "self")

-- | ToJSON ProgramLinks
instance A.ToJSON ProgramLinks where
  toJSON ProgramLinks {..} =
   _omitNulls
      [ "http://ns.adobe.com/adobecloud/rel/pipelines" .= programLinksHttpNsAdobeComAdobecloudRelPipelines
      , "http://ns.adobe.com/adobecloud/rel/environments" .= programLinksHttpNsAdobeComAdobecloudRelEnvironments
      , "http://ns.adobe.com/adobecloud/rel/repositories" .= programLinksHttpNsAdobeComAdobecloudRelRepositories
      , "self" .= programLinksSelf
      ]


-- | Construct a value of type 'ProgramLinks' (by applying it's required fields, if any)
mkProgramLinks
  :: ProgramLinks
mkProgramLinks =
  ProgramLinks
  { programLinksHttpNsAdobeComAdobecloudRelPipelines = Nothing
  , programLinksHttpNsAdobeComAdobecloudRelEnvironments = Nothing
  , programLinksHttpNsAdobeComAdobecloudRelRepositories = Nothing
  , programLinksSelf = Nothing
  }

-- ** ProgramList
-- | ProgramList
data ProgramList = ProgramList
  { programListTotalNumberOfItems :: !(Maybe Int) -- ^ "_totalNumberOfItems"
  , programListEmbedded :: !(Maybe ProgramListEmbedded) -- ^ "_embedded"
  , programListLinks :: !(Maybe ProgramListLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProgramList
instance A.FromJSON ProgramList where
  parseJSON = A.withObject "ProgramList" $ \o ->
    ProgramList
      <$> (o .:? "_totalNumberOfItems")
      <*> (o .:? "_embedded")
      <*> (o .:? "_links")

-- | ToJSON ProgramList
instance A.ToJSON ProgramList where
  toJSON ProgramList {..} =
   _omitNulls
      [ "_totalNumberOfItems" .= programListTotalNumberOfItems
      , "_embedded" .= programListEmbedded
      , "_links" .= programListLinks
      ]


-- | Construct a value of type 'ProgramList' (by applying it's required fields, if any)
mkProgramList
  :: ProgramList
mkProgramList =
  ProgramList
  { programListTotalNumberOfItems = Nothing
  , programListEmbedded = Nothing
  , programListLinks = Nothing
  }

-- ** ProgramListEmbedded
-- | ProgramListEmbedded
data ProgramListEmbedded = ProgramListEmbedded
  { programListEmbeddedPrograms :: !(Maybe [EmbeddedProgram]) -- ^ "programs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProgramListEmbedded
instance A.FromJSON ProgramListEmbedded where
  parseJSON = A.withObject "ProgramListEmbedded" $ \o ->
    ProgramListEmbedded
      <$> (o .:? "programs")

-- | ToJSON ProgramListEmbedded
instance A.ToJSON ProgramListEmbedded where
  toJSON ProgramListEmbedded {..} =
   _omitNulls
      [ "programs" .= programListEmbeddedPrograms
      ]


-- | Construct a value of type 'ProgramListEmbedded' (by applying it's required fields, if any)
mkProgramListEmbedded
  :: ProgramListEmbedded
mkProgramListEmbedded =
  ProgramListEmbedded
  { programListEmbeddedPrograms = Nothing
  }

-- ** ProgramListLinks
-- | ProgramListLinks
data ProgramListLinks = ProgramListLinks
  { programListLinksNext :: !(Maybe HalLink) -- ^ "next"
  , programListLinksPrev :: !(Maybe HalLink) -- ^ "prev"
  , programListLinksSelf :: !(Maybe HalLink) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProgramListLinks
instance A.FromJSON ProgramListLinks where
  parseJSON = A.withObject "ProgramListLinks" $ \o ->
    ProgramListLinks
      <$> (o .:? "next")
      <*> (o .:? "prev")
      <*> (o .:? "self")

-- | ToJSON ProgramListLinks
instance A.ToJSON ProgramListLinks where
  toJSON ProgramListLinks {..} =
   _omitNulls
      [ "next" .= programListLinksNext
      , "prev" .= programListLinksPrev
      , "self" .= programListLinksSelf
      ]


-- | Construct a value of type 'ProgramListLinks' (by applying it's required fields, if any)
mkProgramListLinks
  :: ProgramListLinks
mkProgramListLinks =
  ProgramListLinks
  { programListLinksNext = Nothing
  , programListLinksPrev = Nothing
  , programListLinksSelf = Nothing
  }

-- ** Repository
-- | Repository
-- A sourcecode repository
data Repository = Repository
  { repositoryRepo :: !(Maybe Text) -- ^ "repo" - Repository name
  , repositoryDescription :: !(Maybe Text) -- ^ "description" - description
  , repositoryLinks :: !(Maybe RepositoryLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Repository
instance A.FromJSON Repository where
  parseJSON = A.withObject "Repository" $ \o ->
    Repository
      <$> (o .:? "repo")
      <*> (o .:? "description")
      <*> (o .:? "_links")

-- | ToJSON Repository
instance A.ToJSON Repository where
  toJSON Repository {..} =
   _omitNulls
      [ "repo" .= repositoryRepo
      , "description" .= repositoryDescription
      , "_links" .= repositoryLinks
      ]


-- | Construct a value of type 'Repository' (by applying it's required fields, if any)
mkRepository
  :: Repository
mkRepository =
  Repository
  { repositoryRepo = Nothing
  , repositoryDescription = Nothing
  , repositoryLinks = Nothing
  }

-- ** RepositoryBranch
-- | RepositoryBranch
-- Represents a Git Branch
data RepositoryBranch = RepositoryBranch
  { repositoryBranchProgramId :: !(Maybe Text) -- ^ "programId" - Identifier of the program. Unique within the space
  , repositoryBranchRepositoryId :: !(Maybe Integer) -- ^ "repositoryId" - Identifier of the repository
  , repositoryBranchName :: !(Maybe Text) -- ^ "name" - Name of the branch
  , repositoryBranchLinks :: !(Maybe RepositoryBranchLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RepositoryBranch
instance A.FromJSON RepositoryBranch where
  parseJSON = A.withObject "RepositoryBranch" $ \o ->
    RepositoryBranch
      <$> (o .:? "programId")
      <*> (o .:? "repositoryId")
      <*> (o .:? "name")
      <*> (o .:? "_links")

-- | ToJSON RepositoryBranch
instance A.ToJSON RepositoryBranch where
  toJSON RepositoryBranch {..} =
   _omitNulls
      [ "programId" .= repositoryBranchProgramId
      , "repositoryId" .= repositoryBranchRepositoryId
      , "name" .= repositoryBranchName
      , "_links" .= repositoryBranchLinks
      ]


-- | Construct a value of type 'RepositoryBranch' (by applying it's required fields, if any)
mkRepositoryBranch
  :: RepositoryBranch
mkRepositoryBranch =
  RepositoryBranch
  { repositoryBranchProgramId = Nothing
  , repositoryBranchRepositoryId = Nothing
  , repositoryBranchName = Nothing
  , repositoryBranchLinks = Nothing
  }

-- ** RepositoryBranchLinks
-- | RepositoryBranchLinks
data RepositoryBranchLinks = RepositoryBranchLinks
  { repositoryBranchLinksHttpNsAdobeComAdobecloudRelProgram :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/program"
  , repositoryBranchLinksHttpNsAdobeComAdobecloudRelRepository :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/repository"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RepositoryBranchLinks
instance A.FromJSON RepositoryBranchLinks where
  parseJSON = A.withObject "RepositoryBranchLinks" $ \o ->
    RepositoryBranchLinks
      <$> (o .:? "http://ns.adobe.com/adobecloud/rel/program")
      <*> (o .:? "http://ns.adobe.com/adobecloud/rel/repository")

-- | ToJSON RepositoryBranchLinks
instance A.ToJSON RepositoryBranchLinks where
  toJSON RepositoryBranchLinks {..} =
   _omitNulls
      [ "http://ns.adobe.com/adobecloud/rel/program" .= repositoryBranchLinksHttpNsAdobeComAdobecloudRelProgram
      , "http://ns.adobe.com/adobecloud/rel/repository" .= repositoryBranchLinksHttpNsAdobeComAdobecloudRelRepository
      ]


-- | Construct a value of type 'RepositoryBranchLinks' (by applying it's required fields, if any)
mkRepositoryBranchLinks
  :: RepositoryBranchLinks
mkRepositoryBranchLinks =
  RepositoryBranchLinks
  { repositoryBranchLinksHttpNsAdobeComAdobecloudRelProgram = Nothing
  , repositoryBranchLinksHttpNsAdobeComAdobecloudRelRepository = Nothing
  }

-- ** RepositoryLinks
-- | RepositoryLinks
data RepositoryLinks = RepositoryLinks
  { repositoryLinksHttpNsAdobeComAdobecloudRelProgram :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/program"
  , repositoryLinksHttpNsAdobeComAdobecloudRelBranches :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/branches"
  , repositoryLinksSelf :: !(Maybe HalLink) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RepositoryLinks
instance A.FromJSON RepositoryLinks where
  parseJSON = A.withObject "RepositoryLinks" $ \o ->
    RepositoryLinks
      <$> (o .:? "http://ns.adobe.com/adobecloud/rel/program")
      <*> (o .:? "http://ns.adobe.com/adobecloud/rel/branches")
      <*> (o .:? "self")

-- | ToJSON RepositoryLinks
instance A.ToJSON RepositoryLinks where
  toJSON RepositoryLinks {..} =
   _omitNulls
      [ "http://ns.adobe.com/adobecloud/rel/program" .= repositoryLinksHttpNsAdobeComAdobecloudRelProgram
      , "http://ns.adobe.com/adobecloud/rel/branches" .= repositoryLinksHttpNsAdobeComAdobecloudRelBranches
      , "self" .= repositoryLinksSelf
      ]


-- | Construct a value of type 'RepositoryLinks' (by applying it's required fields, if any)
mkRepositoryLinks
  :: RepositoryLinks
mkRepositoryLinks =
  RepositoryLinks
  { repositoryLinksHttpNsAdobeComAdobecloudRelProgram = Nothing
  , repositoryLinksHttpNsAdobeComAdobecloudRelBranches = Nothing
  , repositoryLinksSelf = Nothing
  }

-- ** RepositoryList
-- | RepositoryList
data RepositoryList = RepositoryList
  { repositoryListTotalNumberOfItems :: !(Maybe Int) -- ^ "_totalNumberOfItems"
  , repositoryListEmbedded :: !(Maybe RepositoryListEmbedded) -- ^ "_embedded"
  , repositoryListLinks :: !(Maybe ProgramListLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RepositoryList
instance A.FromJSON RepositoryList where
  parseJSON = A.withObject "RepositoryList" $ \o ->
    RepositoryList
      <$> (o .:? "_totalNumberOfItems")
      <*> (o .:? "_embedded")
      <*> (o .:? "_links")

-- | ToJSON RepositoryList
instance A.ToJSON RepositoryList where
  toJSON RepositoryList {..} =
   _omitNulls
      [ "_totalNumberOfItems" .= repositoryListTotalNumberOfItems
      , "_embedded" .= repositoryListEmbedded
      , "_links" .= repositoryListLinks
      ]


-- | Construct a value of type 'RepositoryList' (by applying it's required fields, if any)
mkRepositoryList
  :: RepositoryList
mkRepositoryList =
  RepositoryList
  { repositoryListTotalNumberOfItems = Nothing
  , repositoryListEmbedded = Nothing
  , repositoryListLinks = Nothing
  }

-- ** RepositoryListEmbedded
-- | RepositoryListEmbedded
data RepositoryListEmbedded = RepositoryListEmbedded
  { repositoryListEmbeddedRepositories :: !(Maybe [Repository]) -- ^ "repositories"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RepositoryListEmbedded
instance A.FromJSON RepositoryListEmbedded where
  parseJSON = A.withObject "RepositoryListEmbedded" $ \o ->
    RepositoryListEmbedded
      <$> (o .:? "repositories")

-- | ToJSON RepositoryListEmbedded
instance A.ToJSON RepositoryListEmbedded where
  toJSON RepositoryListEmbedded {..} =
   _omitNulls
      [ "repositories" .= repositoryListEmbeddedRepositories
      ]


-- | Construct a value of type 'RepositoryListEmbedded' (by applying it's required fields, if any)
mkRepositoryListEmbedded
  :: RepositoryListEmbedded
mkRepositoryListEmbedded =
  RepositoryListEmbedded
  { repositoryListEmbeddedRepositories = Nothing
  }

-- ** RequestedPageDetails
-- | RequestedPageDetails
-- Filtering and sorting page details
data RequestedPageDetails = RequestedPageDetails
  { requestedPageDetailsStart :: !(Maybe Int) -- ^ "start"
  , requestedPageDetailsLimit :: !(Maybe Int) -- ^ "limit"
  , requestedPageDetailsOrderBy :: !(Maybe Text) -- ^ "orderBy"
  , requestedPageDetailsProperty :: !(Maybe [Text]) -- ^ "property"
  , requestedPageDetailsType :: !(Maybe Text) -- ^ "type"
  , requestedPageDetailsNext :: !(Maybe Int) -- ^ "next"
  , requestedPageDetailsPrev :: !(Maybe Int) -- ^ "prev"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestedPageDetails
instance A.FromJSON RequestedPageDetails where
  parseJSON = A.withObject "RequestedPageDetails" $ \o ->
    RequestedPageDetails
      <$> (o .:? "start")
      <*> (o .:? "limit")
      <*> (o .:? "orderBy")
      <*> (o .:? "property")
      <*> (o .:? "type")
      <*> (o .:? "next")
      <*> (o .:? "prev")

-- | ToJSON RequestedPageDetails
instance A.ToJSON RequestedPageDetails where
  toJSON RequestedPageDetails {..} =
   _omitNulls
      [ "start" .= requestedPageDetailsStart
      , "limit" .= requestedPageDetailsLimit
      , "orderBy" .= requestedPageDetailsOrderBy
      , "property" .= requestedPageDetailsProperty
      , "type" .= requestedPageDetailsType
      , "next" .= requestedPageDetailsNext
      , "prev" .= requestedPageDetailsPrev
      ]


-- | Construct a value of type 'RequestedPageDetails' (by applying it's required fields, if any)
mkRequestedPageDetails
  :: RequestedPageDetails
mkRequestedPageDetails =
  RequestedPageDetails
  { requestedPageDetailsStart = Nothing
  , requestedPageDetailsLimit = Nothing
  , requestedPageDetailsOrderBy = Nothing
  , requestedPageDetailsProperty = Nothing
  , requestedPageDetailsType = Nothing
  , requestedPageDetailsNext = Nothing
  , requestedPageDetailsPrev = Nothing
  }

-- ** Variable
-- | Variable
-- A named value than can be set on an Environment
data Variable = Variable
  { variableName :: !(Maybe Text) -- ^ "name" - Name of the variable. Of a-z, A-Z, _ and 0-9 Cannot begin with a number.
  , variableValue :: !(Maybe Text) -- ^ "value" - Value of the variable. Read-Write for non-secrets, write-only for secrets.
  , variableType :: !(Maybe E'Type3) -- ^ "type" - Type of the variable. Default &#x60;string&#x60; if missing. Cannot be changed after creation.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Variable
instance A.FromJSON Variable where
  parseJSON = A.withObject "Variable" $ \o ->
    Variable
      <$> (o .:? "name")
      <*> (o .:? "value")
      <*> (o .:? "type")

-- | ToJSON Variable
instance A.ToJSON Variable where
  toJSON Variable {..} =
   _omitNulls
      [ "name" .= variableName
      , "value" .= variableValue
      , "type" .= variableType
      ]


-- | Construct a value of type 'Variable' (by applying it's required fields, if any)
mkVariable
  :: Variable
mkVariable =
  Variable
  { variableName = Nothing
  , variableValue = Nothing
  , variableType = Nothing
  }

-- ** VariableList
-- | VariableList
data VariableList = VariableList
  { variableListTotalNumberOfItems :: !(Maybe Int) -- ^ "_totalNumberOfItems"
  , variableListEmbedded :: !(Maybe VariableListEmbedded) -- ^ "_embedded"
  , variableListLinks :: !(Maybe VariableListLinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VariableList
instance A.FromJSON VariableList where
  parseJSON = A.withObject "VariableList" $ \o ->
    VariableList
      <$> (o .:? "_totalNumberOfItems")
      <*> (o .:? "_embedded")
      <*> (o .:? "_links")

-- | ToJSON VariableList
instance A.ToJSON VariableList where
  toJSON VariableList {..} =
   _omitNulls
      [ "_totalNumberOfItems" .= variableListTotalNumberOfItems
      , "_embedded" .= variableListEmbedded
      , "_links" .= variableListLinks
      ]


-- | Construct a value of type 'VariableList' (by applying it's required fields, if any)
mkVariableList
  :: VariableList
mkVariableList =
  VariableList
  { variableListTotalNumberOfItems = Nothing
  , variableListEmbedded = Nothing
  , variableListLinks = Nothing
  }

-- ** VariableListEmbedded
-- | VariableListEmbedded
data VariableListEmbedded = VariableListEmbedded
  { variableListEmbeddedVariables :: !(Maybe [Variable]) -- ^ "variables" - Variables set on environment
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VariableListEmbedded
instance A.FromJSON VariableListEmbedded where
  parseJSON = A.withObject "VariableListEmbedded" $ \o ->
    VariableListEmbedded
      <$> (o .:? "variables")

-- | ToJSON VariableListEmbedded
instance A.ToJSON VariableListEmbedded where
  toJSON VariableListEmbedded {..} =
   _omitNulls
      [ "variables" .= variableListEmbeddedVariables
      ]


-- | Construct a value of type 'VariableListEmbedded' (by applying it's required fields, if any)
mkVariableListEmbedded
  :: VariableListEmbedded
mkVariableListEmbedded =
  VariableListEmbedded
  { variableListEmbeddedVariables = Nothing
  }

-- ** VariableListLinks
-- | VariableListLinks
data VariableListLinks = VariableListLinks
  { variableListLinksHttpNsAdobeComAdobecloudRelEnvironment :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/environment"
  , variableListLinksHttpNsAdobeComAdobecloudRelProgram :: !(Maybe HalLink) -- ^ "http://ns.adobe.com/adobecloud/rel/program"
  , variableListLinksSelf :: !(Maybe HalLink) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VariableListLinks
instance A.FromJSON VariableListLinks where
  parseJSON = A.withObject "VariableListLinks" $ \o ->
    VariableListLinks
      <$> (o .:? "http://ns.adobe.com/adobecloud/rel/environment")
      <*> (o .:? "http://ns.adobe.com/adobecloud/rel/program")
      <*> (o .:? "self")

-- | ToJSON VariableListLinks
instance A.ToJSON VariableListLinks where
  toJSON VariableListLinks {..} =
   _omitNulls
      [ "http://ns.adobe.com/adobecloud/rel/environment" .= variableListLinksHttpNsAdobeComAdobecloudRelEnvironment
      , "http://ns.adobe.com/adobecloud/rel/program" .= variableListLinksHttpNsAdobeComAdobecloudRelProgram
      , "self" .= variableListLinksSelf
      ]


-- | Construct a value of type 'VariableListLinks' (by applying it's required fields, if any)
mkVariableListLinks
  :: VariableListLinks
mkVariableListLinks =
  VariableListLinks
  { variableListLinksHttpNsAdobeComAdobecloudRelEnvironment = Nothing
  , variableListLinksHttpNsAdobeComAdobecloudRelProgram = Nothing
  , variableListLinksSelf = Nothing
  }


-- * Enums


-- ** E'Comparator

-- | Enum of 'Text' . 
-- Comparator used for the metric
data E'Comparator
  = E'Comparator'GT -- ^ @"GT"@
  | E'Comparator'GTE -- ^ @"GTE"@
  | E'Comparator'LT -- ^ @"LT"@
  | E'Comparator'LTE -- ^ @"LTE"@
  | E'Comparator'EQ -- ^ @"EQ"@
  | E'Comparator'NEQ -- ^ @"NEQ"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Comparator where toJSON = A.toJSON . fromE'Comparator
instance A.FromJSON E'Comparator where parseJSON o = P.either P.fail (pure . P.id) . toE'Comparator =<< A.parseJSON o
instance WH.ToHttpApiData E'Comparator where toQueryParam = WH.toQueryParam . fromE'Comparator
instance WH.FromHttpApiData E'Comparator where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Comparator
instance MimeRender MimeMultipartFormData E'Comparator where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Comparator' enum
fromE'Comparator :: E'Comparator -> Text
fromE'Comparator = \case
  E'Comparator'GT -> "GT"
  E'Comparator'GTE -> "GTE"
  E'Comparator'LT -> "LT"
  E'Comparator'LTE -> "LTE"
  E'Comparator'EQ -> "EQ"
  E'Comparator'NEQ -> "NEQ"

-- | parse 'E'Comparator' enum
toE'Comparator :: Text -> P.Either String E'Comparator
toE'Comparator = \case
  "GT" -> P.Right E'Comparator'GT
  "GTE" -> P.Right E'Comparator'GTE
  "LT" -> P.Right E'Comparator'LT
  "LTE" -> P.Right E'Comparator'LTE
  "EQ" -> P.Right E'Comparator'EQ
  "NEQ" -> P.Right E'Comparator'NEQ
  s -> P.Left $ "toE'Comparator: enum parse failure: " P.++ P.show s


-- ** E'Severity

-- | Enum of 'Text' . 
-- Severity of the metric
data E'Severity
  = E'Severity'Critical -- ^ @"critical"@
  | E'Severity'Important -- ^ @"important"@
  | E'Severity'Informational -- ^ @"informational"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Severity where toJSON = A.toJSON . fromE'Severity
instance A.FromJSON E'Severity where parseJSON o = P.either P.fail (pure . P.id) . toE'Severity =<< A.parseJSON o
instance WH.ToHttpApiData E'Severity where toQueryParam = WH.toQueryParam . fromE'Severity
instance WH.FromHttpApiData E'Severity where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Severity
instance MimeRender MimeMultipartFormData E'Severity where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Severity' enum
fromE'Severity :: E'Severity -> Text
fromE'Severity = \case
  E'Severity'Critical -> "critical"
  E'Severity'Important -> "important"
  E'Severity'Informational -> "informational"

-- | parse 'E'Severity' enum
toE'Severity :: Text -> P.Either String E'Severity
toE'Severity = \case
  "critical" -> P.Right E'Severity'Critical
  "important" -> P.Right E'Severity'Important
  "informational" -> P.Right E'Severity'Informational
  s -> P.Left $ "toE'Severity: enum parse failure: " P.++ P.show s


-- ** E'Status

-- | Enum of 'Text' . 
-- Pipeline status
data E'Status
  = E'Status'IDLE -- ^ @"IDLE"@
  | E'Status'BUSY -- ^ @"BUSY"@
  | E'Status'WAITING -- ^ @"WAITING"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status where toJSON = A.toJSON . fromE'Status
instance A.FromJSON E'Status where parseJSON o = P.either P.fail (pure . P.id) . toE'Status =<< A.parseJSON o
instance WH.ToHttpApiData E'Status where toQueryParam = WH.toQueryParam . fromE'Status
instance WH.FromHttpApiData E'Status where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status
instance MimeRender MimeMultipartFormData E'Status where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status' enum
fromE'Status :: E'Status -> Text
fromE'Status = \case
  E'Status'IDLE -> "IDLE"
  E'Status'BUSY -> "BUSY"
  E'Status'WAITING -> "WAITING"

-- | parse 'E'Status' enum
toE'Status :: Text -> P.Either String E'Status
toE'Status = \case
  "IDLE" -> P.Right E'Status'IDLE
  "BUSY" -> P.Right E'Status'BUSY
  "WAITING" -> P.Right E'Status'WAITING
  s -> P.Left $ "toE'Status: enum parse failure: " P.++ P.show s


-- ** E'Status2

-- | Enum of 'Text' . 
-- Status of the execution
data E'Status2
  = E'Status2'NOT_STARTED -- ^ @"NOT_STARTED"@
  | E'Status2'RUNNING -- ^ @"RUNNING"@
  | E'Status2'CANCELLING -- ^ @"CANCELLING"@
  | E'Status2'CANCELLED -- ^ @"CANCELLED"@
  | E'Status2'FINISHED -- ^ @"FINISHED"@
  | E'Status2'ERROR -- ^ @"ERROR"@
  | E'Status2'FAILED -- ^ @"FAILED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status2 where toJSON = A.toJSON . fromE'Status2
instance A.FromJSON E'Status2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Status2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Status2 where toQueryParam = WH.toQueryParam . fromE'Status2
instance WH.FromHttpApiData E'Status2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status2
instance MimeRender MimeMultipartFormData E'Status2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status2' enum
fromE'Status2 :: E'Status2 -> Text
fromE'Status2 = \case
  E'Status2'NOT_STARTED -> "NOT_STARTED"
  E'Status2'RUNNING -> "RUNNING"
  E'Status2'CANCELLING -> "CANCELLING"
  E'Status2'CANCELLED -> "CANCELLED"
  E'Status2'FINISHED -> "FINISHED"
  E'Status2'ERROR -> "ERROR"
  E'Status2'FAILED -> "FAILED"

-- | parse 'E'Status2' enum
toE'Status2 :: Text -> P.Either String E'Status2
toE'Status2 = \case
  "NOT_STARTED" -> P.Right E'Status2'NOT_STARTED
  "RUNNING" -> P.Right E'Status2'RUNNING
  "CANCELLING" -> P.Right E'Status2'CANCELLING
  "CANCELLED" -> P.Right E'Status2'CANCELLED
  "FINISHED" -> P.Right E'Status2'FINISHED
  "ERROR" -> P.Right E'Status2'ERROR
  "FAILED" -> P.Right E'Status2'FAILED
  s -> P.Left $ "toE'Status2: enum parse failure: " P.++ P.show s


-- ** E'Status3

-- | Enum of 'Text' . 
-- Action status
data E'Status3
  = E'Status3'NOT_STARTED -- ^ @"NOT_STARTED"@
  | E'Status3'RUNNING -- ^ @"RUNNING"@
  | E'Status3'FINISHED -- ^ @"FINISHED"@
  | E'Status3'ERROR -- ^ @"ERROR"@
  | E'Status3'ROLLING_BACK -- ^ @"ROLLING_BACK"@
  | E'Status3'ROLLED_BACK -- ^ @"ROLLED_BACK"@
  | E'Status3'WAITING -- ^ @"WAITING"@
  | E'Status3'CANCELLED -- ^ @"CANCELLED"@
  | E'Status3'FAILED -- ^ @"FAILED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status3 where toJSON = A.toJSON . fromE'Status3
instance A.FromJSON E'Status3 where parseJSON o = P.either P.fail (pure . P.id) . toE'Status3 =<< A.parseJSON o
instance WH.ToHttpApiData E'Status3 where toQueryParam = WH.toQueryParam . fromE'Status3
instance WH.FromHttpApiData E'Status3 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status3
instance MimeRender MimeMultipartFormData E'Status3 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status3' enum
fromE'Status3 :: E'Status3 -> Text
fromE'Status3 = \case
  E'Status3'NOT_STARTED -> "NOT_STARTED"
  E'Status3'RUNNING -> "RUNNING"
  E'Status3'FINISHED -> "FINISHED"
  E'Status3'ERROR -> "ERROR"
  E'Status3'ROLLING_BACK -> "ROLLING_BACK"
  E'Status3'ROLLED_BACK -> "ROLLED_BACK"
  E'Status3'WAITING -> "WAITING"
  E'Status3'CANCELLED -> "CANCELLED"
  E'Status3'FAILED -> "FAILED"

-- | parse 'E'Status3' enum
toE'Status3 :: Text -> P.Either String E'Status3
toE'Status3 = \case
  "NOT_STARTED" -> P.Right E'Status3'NOT_STARTED
  "RUNNING" -> P.Right E'Status3'RUNNING
  "FINISHED" -> P.Right E'Status3'FINISHED
  "ERROR" -> P.Right E'Status3'ERROR
  "ROLLING_BACK" -> P.Right E'Status3'ROLLING_BACK
  "ROLLED_BACK" -> P.Right E'Status3'ROLLED_BACK
  "WAITING" -> P.Right E'Status3'WAITING
  "CANCELLED" -> P.Right E'Status3'CANCELLED
  "FAILED" -> P.Right E'Status3'FAILED
  s -> P.Left $ "toE'Status3: enum parse failure: " P.++ P.show s


-- ** E'Trigger

-- | Enum of 'Text' . 
-- How should the execution be triggered. ON_COMMIT: each time a PR is available and the Pipeline is idle then a execution is triggered. MANUAL: triggerd through UI or API. SCHEDULE: recurring schedule (not yet implemented}
data E'Trigger
  = E'Trigger'ON_COMMIT -- ^ @"ON_COMMIT"@
  | E'Trigger'MANUAL -- ^ @"MANUAL"@
  | E'Trigger'SCHEDULE -- ^ @"SCHEDULE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Trigger where toJSON = A.toJSON . fromE'Trigger
instance A.FromJSON E'Trigger where parseJSON o = P.either P.fail (pure . P.id) . toE'Trigger =<< A.parseJSON o
instance WH.ToHttpApiData E'Trigger where toQueryParam = WH.toQueryParam . fromE'Trigger
instance WH.FromHttpApiData E'Trigger where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Trigger
instance MimeRender MimeMultipartFormData E'Trigger where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Trigger' enum
fromE'Trigger :: E'Trigger -> Text
fromE'Trigger = \case
  E'Trigger'ON_COMMIT -> "ON_COMMIT"
  E'Trigger'MANUAL -> "MANUAL"
  E'Trigger'SCHEDULE -> "SCHEDULE"

-- | parse 'E'Trigger' enum
toE'Trigger :: Text -> P.Either String E'Trigger
toE'Trigger = \case
  "ON_COMMIT" -> P.Right E'Trigger'ON_COMMIT
  "MANUAL" -> P.Right E'Trigger'MANUAL
  "SCHEDULE" -> P.Right E'Trigger'SCHEDULE
  s -> P.Left $ "toE'Trigger: enum parse failure: " P.++ P.show s


-- ** E'Trigger2

-- | Enum of 'Text' . 
-- How the execution was triggered.
data E'Trigger2
  = E'Trigger2'ON_COMMIT -- ^ @"ON_COMMIT"@
  | E'Trigger2'MANUAL -- ^ @"MANUAL"@
  | E'Trigger2'SCHEDULE -- ^ @"SCHEDULE"@
  | E'Trigger2'PUSH_UPGRADES -- ^ @"PUSH_UPGRADES"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Trigger2 where toJSON = A.toJSON . fromE'Trigger2
instance A.FromJSON E'Trigger2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Trigger2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Trigger2 where toQueryParam = WH.toQueryParam . fromE'Trigger2
instance WH.FromHttpApiData E'Trigger2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Trigger2
instance MimeRender MimeMultipartFormData E'Trigger2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Trigger2' enum
fromE'Trigger2 :: E'Trigger2 -> Text
fromE'Trigger2 = \case
  E'Trigger2'ON_COMMIT -> "ON_COMMIT"
  E'Trigger2'MANUAL -> "MANUAL"
  E'Trigger2'SCHEDULE -> "SCHEDULE"
  E'Trigger2'PUSH_UPGRADES -> "PUSH_UPGRADES"

-- | parse 'E'Trigger2' enum
toE'Trigger2 :: Text -> P.Either String E'Trigger2
toE'Trigger2 = \case
  "ON_COMMIT" -> P.Right E'Trigger2'ON_COMMIT
  "MANUAL" -> P.Right E'Trigger2'MANUAL
  "SCHEDULE" -> P.Right E'Trigger2'SCHEDULE
  "PUSH_UPGRADES" -> P.Right E'Trigger2'PUSH_UPGRADES
  s -> P.Left $ "toE'Trigger2: enum parse failure: " P.++ P.show s


-- ** E'Type

-- | Enum of 'Text' . 
-- Type of the phase
data E'Type
  = E'Type'VALIDATE -- ^ @"VALIDATE"@
  | E'Type'BUILD -- ^ @"BUILD"@
  | E'Type'DEPLOY -- ^ @"DEPLOY"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type where toJSON = A.toJSON . fromE'Type
instance A.FromJSON E'Type where parseJSON o = P.either P.fail (pure . P.id) . toE'Type =<< A.parseJSON o
instance WH.ToHttpApiData E'Type where toQueryParam = WH.toQueryParam . fromE'Type
instance WH.FromHttpApiData E'Type where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type
instance MimeRender MimeMultipartFormData E'Type where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type' enum
fromE'Type :: E'Type -> Text
fromE'Type = \case
  E'Type'VALIDATE -> "VALIDATE"
  E'Type'BUILD -> "BUILD"
  E'Type'DEPLOY -> "DEPLOY"

-- | parse 'E'Type' enum
toE'Type :: Text -> P.Either String E'Type
toE'Type = \case
  "VALIDATE" -> P.Right E'Type'VALIDATE
  "BUILD" -> P.Right E'Type'BUILD
  "DEPLOY" -> P.Right E'Type'DEPLOY
  s -> P.Left $ "toE'Type: enum parse failure: " P.++ P.show s


-- ** E'Type2

-- | Enum of 'Text' . 
-- Type of the environment
data E'Type2
  = E'Type2'Dev -- ^ @"dev"@
  | E'Type2'Stage -- ^ @"stage"@
  | E'Type2'Prod -- ^ @"prod"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type2 where toJSON = A.toJSON . fromE'Type2
instance A.FromJSON E'Type2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type2 where toQueryParam = WH.toQueryParam . fromE'Type2
instance WH.FromHttpApiData E'Type2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type2
instance MimeRender MimeMultipartFormData E'Type2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type2' enum
fromE'Type2 :: E'Type2 -> Text
fromE'Type2 = \case
  E'Type2'Dev -> "dev"
  E'Type2'Stage -> "stage"
  E'Type2'Prod -> "prod"

-- | parse 'E'Type2' enum
toE'Type2 :: Text -> P.Either String E'Type2
toE'Type2 = \case
  "dev" -> P.Right E'Type2'Dev
  "stage" -> P.Right E'Type2'Stage
  "prod" -> P.Right E'Type2'Prod
  s -> P.Left $ "toE'Type2: enum parse failure: " P.++ P.show s


-- ** E'Type3

-- | Enum of 'Text' . 
-- Type of the variable. Default `string` if missing. Cannot be changed after creation.
data E'Type3
  = E'Type3'String -- ^ @"string"@
  | E'Type3'SecretString -- ^ @"secretString"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type3 where toJSON = A.toJSON . fromE'Type3
instance A.FromJSON E'Type3 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type3 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type3 where toQueryParam = WH.toQueryParam . fromE'Type3
instance WH.FromHttpApiData E'Type3 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type3
instance MimeRender MimeMultipartFormData E'Type3 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type3' enum
fromE'Type3 :: E'Type3 -> Text
fromE'Type3 = \case
  E'Type3'String -> "string"
  E'Type3'SecretString -> "secretString"

-- | parse 'E'Type3' enum
toE'Type3 :: Text -> P.Either String E'Type3
toE'Type3 = \case
  "string" -> P.Right E'Type3'String
  "secretString" -> P.Right E'Type3'SecretString
  s -> P.Left $ "toE'Type3: enum parse failure: " P.++ P.show s



